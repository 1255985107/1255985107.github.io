<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CCPC Final 2023 J Solution</title>
    <url>/2024/04/16/CCPC-Final-2023-J-Solution/</url>
    <content><![CDATA[<p>本文讨论 CCPC Final 2023 J 的与官方解法（from Lynkcat）略有区别的线性解法。</p>
<p>题目传送门：<a href="https://contest.ucup.ac/contest/1596/problem/8551">CCPC Final 2023 J</a></p>
<p>题解视频传送门：<a href="https://www.bilibili.com/video/BV17m411z7Am/?t=1820">第九届 CCPC 总决赛题解</a></p>
<span id="more"></span>
<p>我们设给出的序列为 <span class="math inline">\(q\)</span>。</p>
<p><span class="math inline">\(q_1\)</span> 是一个特殊的点，因为它的所有祖先构成了一条链，这条链上的点的儿子可以不出现在合法的子段中。</p>
<p>构造方法：所有没有出现的儿子，把它们的子树整个地放在这个点的后面、<span class="math inline">\(q_1\)</span> 的前面。</p>
<p>同时要指出，合法的子段就是取出这条链的一些儿子，按深度递减的顺序排列，然后按这个顺序链接它们子树的 DFS 序。</p>
<p>假设我们处理到 <span class="math inline">\(q_i\)</span>。 不妨设 <span class="math inline">\(x = q_{i - 1}, y = q_i\)</span>，一样地讨论两者的关系。</p>
<h3 id="y-在-x-子树内"><span class="math inline">\(y\)</span> 在 <span class="math inline">\(x\)</span> 子树内</h3>
<p>这个时候 <span class="math inline">\(y\)</span> 必须是 <span class="math inline">\(x\)</span> 的儿子，否则从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 中间一定经过一个点 <span class="math inline">\(p\)</span>，使得 <span class="math inline">\(p\)</span> 是 <span class="math inline">\(x\)</span> 的儿子且是 <span class="math inline">\(y\)</span> 的祖先。</p>
<p>这个条件还是很好判断的。</p>
<h3 id="y-不在-x-子树内"><span class="math inline">\(y\)</span> 不在 <span class="math inline">\(x\)</span> 子树内</h3>
<p>这个情况一般就是结束了某个子树的遍历，跳到另一个子树内了。</p>
<p>我们知道，从 <span class="math inline">\(x\)</span> 到 <span class="math inline">\(y\)</span> 如果有 <span class="math inline">\(k\)</span> 条向下的边，那么 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 在 DFS 序上的距离至少为 <span class="math inline">\(k - 1\)</span>。</p>
<p>所以这个时候只能有 <span class="math inline">\(1\)</span> 条向下的边，那么 <span class="math inline">\(y\)</span> 的父亲就会落在 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(x\)</span> 的路径上，是 <span class="math inline">\(x\)</span> 的祖先，这个点记为 <span class="math inline">\(p\)</span>。</p>
<p>从 <span class="math inline">\(x\)</span> 回溯到 <span class="math inline">\(p\)</span>，意味着 <span class="math inline">\(p\)</span> 子树内的点不能再被遍历了，我们就要判断它们是否有遗漏的点需要放在 <span class="math inline">\(x\)</span> 和 <span class="math inline">\(y\)</span> 之间。</p>
<p>注意特殊链上的点可以遗漏一些儿子，所以我们先考虑 <span class="math inline">\(p\)</span> 不在特殊链上，<span class="math inline">\(x\)</span> 到 <span class="math inline">\(p\)</span> 中被访问的点的子树。</p>
<p>我们维护一个栈表示 <span class="math inline">\(1\)</span> 到 <span class="math inline">\(x\)</span> 路径上，在子段中（被访问过）的点 <span class="math inline">\(st_p\)</span>。同时记录它们子树中被访问过的点的个数 <span class="math inline">\(cnt_p\)</span>。</p>
<p>这里需要预处理每个点的子树大小 <span class="math inline">\(size_x\)</span>。对于栈顶，如果 <span class="math inline">\(cnt_p \neq size_{st_p}\)</span>，说明 <span class="math inline">\(st_p\)</span> 子树不满，不合法。</p>
<p>否则将 <span class="math inline">\(st_p\)</span> 弹出，<span class="math inline">\(cnt_p\)</span> 加到新的栈顶 <span class="math inline">\(st_p^{\prime}\)</span> 的 <span class="math inline">\(cnt_p^{\prime}\)</span>，<span class="math inline">\(st_p^{\prime}\)</span> 一定是 <span class="math inline">\(st_p\)</span> 的父亲。</p>
<p>注意栈中的 <span class="math inline">\(p\)</span> 不需要检查或弹出。完成之后插入 <span class="math inline">\(y\)</span> 即可。</p>
<p>如果 <span class="math inline">\(p\)</span> 在特殊链上，栈中就不存在 <span class="math inline">\(p\)</span>。这种情况下，我们逐个检查和弹出整个栈即可。</p>
<p>再来讨论 <span class="math inline">\(p\)</span> 在特殊链上的情况。</p>
<p>每当出现这种情况，<span class="math inline">\(y, p\)</span> 的深度一定不减，而且同深度的 <span class="math inline">\(y\)</span> 显然是同一个 <span class="math inline">\(p\)</span> 的儿子。</p>
<p>所以当出现 <span class="math inline">\(y\)</span> 深度增大时不合法。</p>
<p>会不会出现同一个儿子多次访问呢？考虑这个儿子 <span class="math inline">\(y\)</span> 在不在特殊链上。</p>
<p>如果 <span class="math inline">\(y\)</span> 不在特殊链上，进入 <span class="math inline">\(y\)</span> 时一定要访问 <span class="math inline">\(y\)</span>，我们的标记可以帮助排除。</p>
<p>如果 <span class="math inline">\(y\)</span> 在特殊链上，则访问 <span class="math inline">\(q_1\)</span> 时已经访问了 <span class="math inline">\(y\)</span>，一定不合法。</p>
<p>实现中要注意：</p>
<ol type="1">
<li><p>是否被访问的标记应该采用撤销的方式清除，这样总的复杂度才能保持 <span class="math inline">\(O(\sum k)\)</span> 而不退化为 <span class="math inline">\(O(nQ)\)</span>。</p></li>
<li><p>可以预处理一个 DFS 序用于判断点对 <span class="math inline">\((x, y)\)</span> 是否构成祖先与后代的关系。</p></li>
</ol>
<h3 id="代码">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head[N], ver[N &lt;&lt; <span class="number">1</span>], nxt[N &lt;&lt; <span class="number">1</span>], tot = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> fa[N], dep[N], siz[N];</span><br><span class="line"><span class="type">int</span> dfn[N], num;</span><br><span class="line"><span class="type">bool</span> vis[N];</span><br><span class="line"><span class="type">int</span> q[N * <span class="number">10</span>], n;</span><br><span class="line"><span class="type">int</span> sta[N], sum[N], tp;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">addedge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    ver[++tot] = y; nxt[tot] = head[x]; head[x] = tot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    dfn[x] = ++num;</span><br><span class="line">    siz[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = head[x], y; y = ver[k], k; k = nxt[k])&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == fa[x]) <span class="keyword">continue</span>;</span><br><span class="line">        fa[y] = x;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chkson</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfn[x] &lt; dfn[y] &amp;&amp; dfn[y] &lt; dfn[x] + siz[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    tp++;</span><br><span class="line">    vis[x] = <span class="number">1</span>;</span><br><span class="line">    sta[tp] = x;</span><br><span class="line">    sum[tp] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> m = <span class="built_in">read</span>(), ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        q[i] = <span class="built_in">read</span>();</span><br><span class="line">    tp = <span class="number">0</span>;</span><br><span class="line">    sum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">push</span>(q[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>, x, y = q[<span class="number">1</span>], mind = dep[q[<span class="number">1</span>]]; x = y, y = q[i], i &lt;= m &amp;&amp; ans; ++i)</span><br><span class="line">    <span class="keyword">if</span>(vis[y] || <span class="built_in">chkson</span>(y, q[<span class="number">1</span>])) ans = <span class="number">0</span>;<span class="comment">// y visited or is on the virtual list</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">chkson</span>(x, y))&#123;<span class="comment">// y is son of x</span></span><br><span class="line">        <span class="keyword">if</span>(dep[y] != dep[x] + <span class="number">1</span>) ans = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> t = fa[y];</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">chkson</span>(t, x)) ans = <span class="number">0</span>;<span class="comment">// t must be the ancestor of x</span></span><br><span class="line">        <span class="keyword">if</span>(siz[x] != <span class="number">1</span>) ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(tp)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sum[tp] != siz[sta[tp]]) ans = <span class="number">0</span>;<span class="comment">// subtree shoud be fully visited</span></span><br><span class="line">            sum[tp - <span class="number">1</span>] += sum[tp];</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">chkson</span>(y, sta[tp])) ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(sta[--tp] == t) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!vis[t])&#123;<span class="comment">// t is on the virtual list</span></span><br><span class="line">            <span class="keyword">if</span>(dep[y] &gt; mind) ans = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(mind &gt; dep[y]) mind = dep[y];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">push</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        vis[q[i]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt; n; ++i)&#123;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>();</span><br><span class="line">        <span class="built_in">addedge</span>(x, y); <span class="built_in">addedge</span>(y, x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">solve</span>()? <span class="string">&quot;Yes&quot;</span>: <span class="string">&quot;No&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>UCUP</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 910 (Div. 2) Solution</title>
    <url>/2023/11/26/Codeforces-Round-910-Div2-Solution/</url>
    <content><![CDATA[<p>目前进度：</p>
<table style="width:100%;">
<colgroup>
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 18%" />
<col style="width: 13%" />
<col style="width: 13%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">E</th>
<th style="text-align: center;">F</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">not solved</td>
<td style="text-align: center;">not solved</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="a.-milica-and-string">A. Milica and String</h2>
<h2 id="b.-milena-and-admirer">B. Milena and Admirer</h2>
<h2 id="c.-colorful-grid">C. Colorful Grid</h2>
<h2 id="d.-absolute-beauty">D. Absolute Beauty</h2>
<h2 id="e.-sofia-and-strings">E. Sofia and Strings</h2>
<h2 id="f.-vova-escapes-the-matrix">F. Vova Escapes the Matrix</h2>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>2024寒假计划</title>
    <url>/2024/01/14/2024%E5%AF%92%E5%81%87%E8%AE%A1%E5%88%92/</url>
    <content><![CDATA[<p>本文动笔的时候，博主距逃离人间天堂只差一门 17 号的考试，想着趁这个时间梳理一下自己寒假的计划，顺便立一下 flag。</p>
<span id="more"></span>
<p>寒假从 1 月 19 号开始算，感觉到 2 月 19 号差不多就要回杭了。</p>
<p>首先是主要活动：</p>
<ol type="1">
<li><p>返校宣讲：其实是寒假招生，按大联要求 21 号去开会，27 号正式活动。浙大在北中还是太稀有了，考虑到可能的生源，压力也不是特别大。三个人的小队已经分好工了，这几天把讲稿准备一下，看看有机会就上 1688 整点文件袋回去。<del>得想办法让他们来浙大陪我</del></p></li>
<li><p>学车：只考了科目一，得花时间去练车场了。感觉自己有偷懒的可能性，到时候得想点办法逼自己去了。</p></li>
<li><p>拜年：2 月 4 号立春，2 月 10 号春节，节前节后还是有挺多活动的。</p></li>
</ol>
<p>盘算了一下，最近想学的东西还挺多，按优先级排一下：</p>
<ol type="1">
<li><p>《组合数学》的内容，我不信上大学了还看不懂</p></li>
<li><p>Python，别天天用你那 C++ 了</p></li>
<li><p>OOP，也算是为下学期的专业课打个底</p></li>
<li><p>Vim，看以后能不能进化到只用键盘</p></li>
<li><p>HTML 与 LaTeX，让自己有一点写网页的水平</p></li>
<li><p>CSS，教程太长了一直没看</p></li>
</ol>
<p>以上内容主打一个尽力，没学完就算了。</p>
<p>希望再开学的时候能达到自己满意的效果吧。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>none</category>
      </categories>
      <tags>
        <tag>gossip</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 926 (Div. 2) Solution</title>
    <url>/2024/02/16/Codeforces-Round-926-Div-2-Solution/</url>
    <content><![CDATA[<p>目前进度：</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 12%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">E</th>
<th style="text-align: center;">F</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">not solved</td>
<td style="text-align: center;">solved later</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="a.-sasha-and-the-beautiful-array">A. Sasha and the Beautiful Array</h2>
<h3 id="简要翻译">简要翻译</h3>
<p>给定一个数组 <span class="math inline">\(a\)</span>，可以随意交换元素，最大化 <span class="math inline">\(\sum_{i=2}^{n} (a_i - a_{i-1})\)</span>。</p>
<h3 id="思路解析">思路解析</h3>
<p><span class="math inline">\(\sum_{i=2}^{n} (a_i - a_{i-1}) = a_n - a_1\)</span>，所以最大值减最小值即可。</p>
<h3 id="代码">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line">ll a[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    ll mina=<span class="number">1000000000</span>,maxa=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        a[i]=<span class="built_in">read</span>(),</span><br><span class="line">        mina=<span class="built_in">min</span>(mina,a[i]),</span><br><span class="line">        maxa=<span class="built_in">max</span>(maxa,a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,maxa-mina);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;order.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;order.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="b.-sasha-and-the-drawing">B. Sasha and the Drawing</h2>
<h3 id="简要翻译-1">简要翻译</h3>
<p>给定一个 <span class="math inline">\(n \times n\)</span> 的方格网，求最少的填色块数，使得至少 <span class="math inline">\(k\)</span> 条对角线上有被染色的格子。</p>
<p>正方向（左上-右下方向）与负方向各有 <span class="math inline">\(2n - 1\)</span> 条对角线，所以 <span class="math inline">\(k \leq 4n - 2\)</span>。</p>
<h3 id="思路解析-1">思路解析</h3>
<p>首先，每多 <span class="math inline">\(1\)</span> 个填色块，有颜色的对角线个数最多 <span class="math inline">\(+2\)</span>。</p>
<p>我们可以先给第 <span class="math inline">\(1\)</span> 行的方格填色，这样每次填色增加的对角线都没有重复。</p>
<p>接下来画个图，发现正方向和负方向的对角线各被统计了 <span class="math inline">\(n\)</span> 条。</p>
<p>而在第 <span class="math inline">\(n\)</span> 行，除了 <span class="math inline">\((n,1)\)</span> 与 <span class="math inline">\((n,n)\)</span>，其他方格填色仍然能使有颜色的对角线个数 <span class="math inline">\(+2\)</span>。 对于 <span class="math inline">\((n,1)\)</span> 和 <span class="math inline">\((n,n)\)</span>，选它们的贡献只有 <span class="math inline">\(1\)</span>。</p>
<p>所以 <span class="math inline">\(k \leq 2(2n - 2)\)</span> 时，答案为 <span class="math inline">\(\lceil \frac{k}{2} \rceil\)</span>。如果 <span class="math inline">\(4n - 4 &lt; k \leq 4n - 2\)</span>，则答案为 <span class="math inline">\(k - 2n + 2\)</span>。</p>
<h3 id="代码-1">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll n=<span class="built_in">read</span>(),k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(k&lt;=(n*<span class="number">4</span><span class="number">-4</span>))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(k+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,k<span class="number">-2</span>*n+<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;order.in&quot;</span>,<span class="string">&quot;r&quot;</span>,stdin);</span><br><span class="line">    <span class="built_in">freopen</span>(<span class="string">&quot;order.out&quot;</span>,<span class="string">&quot;w&quot;</span>,stdout);</span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="c.-sasha-and-the-casino">C. Sasha and the Casino</h2>
<h3 id="简要翻译-2">简要翻译</h3>
<p>Sasha 去赌场玩，可以下赌若干次。每局赌注的金额为正整数且不超过 Sasha 现有资金。</p>
<p>设赌注金额为 <span class="math inline">\(y\)</span>，若赢了可以得到 <span class="math inline">\((k - 1) \cdot y\)</span>，若输了则失去 <span class="math inline">\(y\)</span>。</p>
<p>赌场有一个特殊机制：连输 <span class="math inline">\(x\)</span> 局后下一局必赢。当然，赌场里有很多手脚，不违反机制的情况下可以操控任意一局的输赢。</p>
<p>Sasha 的启动资金为 <span class="math inline">\(a\)</span>，问适当策略下 Sasha 能否赚到无限多的钱。</p>
<h3 id="思路解析-2">思路解析</h3>
<p>因为前 <span class="math inline">\(x+1\)</span> 局里一定有一局赢，所以我们只要考虑在这个区间赢一局能否赚到。</p>
<p>如果可以，那么钱就能一直变多；如果不能，那么赌场就可以在适当的时间让你赢一局（中断连败），同时你还亏钱，不可能越赌越多。</p>
<p>设 <span class="math inline">\(y\)</span> 为本次下注的最小金额，<span class="math inline">\(z\)</span> 为此次下注之前已经输了的钱。</p>
<p>如果这次赢了，那么必须赚到，所以 <span class="math inline">\((k - 1) \cdot y &gt; z \Rightarrow y = \lfloor \frac{z}{k-1} \rfloor + 1\)</span>。</p>
<p>本次下注金额不能超过现有资金，有 <span class="math inline">\(y \leq a - z\)</span>。</p>
<p>输了 <span class="math inline">\(z\)</span> 变为 <span class="math inline">\(z + y\)</span>，到下一轮。</p>
<p>如果第 <span class="math inline">\(x+1\)</span> 轮仍有 <span class="math inline">\(y \leq a - z\)</span>，说明 Sasha 一定能回本且赚钱。</p>
<h3 id="代码-2">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll k=<span class="built_in">read</span>(),x=<span class="built_in">read</span>(),a=<span class="built_in">read</span>(),z=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=x+<span class="number">1</span>;++i)&#123;</span><br><span class="line">        ll y=z/(k<span class="number">-1</span>)+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i==<span class="number">1</span>)y=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(y&gt;a-z)<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        z+=y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;order.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;order.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">puts</span>(<span class="built_in">work</span>()?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="d.-sasha-and-a-walk-in-the-city">D. Sasha and a Walk in the City</h2>
<h3 id="简要翻译-3">简要翻译</h3>
<p>给定一棵树，求如下点集的数量：</p>
<p>若将点集中的点染黑，任意一条树上简单路径中黑点不超过两个。</p>
<h3 id="思路解析-3">思路解析</h3>
<p>类似树上 dp 的做法。</p>
<p>当一个点 <span class="math inline">\(x\)</span> <strong>不能</strong>被选中，一定是以下两种情况之一：</p>
<ol type="1">
<li><p>有至少两个子树，它们中有选中点。这两个黑点的路径上包括了 <span class="math inline">\(x\)</span>，<span class="math inline">\(x\)</span> 不能选。</p></li>
<li><p>有一个子树，其中某两个选中点构成父子关系。从 <span class="math inline">\(x\)</span> 到更深的那个黑点的路径上有两个黑点，<span class="math inline">\(x\)</span> 不能选。</p></li>
</ol>
<p>设 <span class="math inline">\(f_x\)</span> 为 <span class="math inline">\(x\)</span> 子树内<strong>不存在父子关系</strong>的点集方案数， <span class="math inline">\(g_x\)</span> 为 <span class="math inline">\(x\)</span> 子树内<strong>存在父子关系</strong>的点集方案数。</p>
<p>考虑 <span class="math inline">\(x\)</span> 子树内不存在父子关系。若不选 <span class="math inline">\(x\)</span>，其儿子 <span class="math inline">\(y\)</span> 之间的方案相互独立，可以相乘。然后再加上一个只选 <span class="math inline">\(x\)</span> 的方案。</p>
<p><span class="math display">\[
f_x = \prod_{y \in \mathrm{son}(x)} f_y + 1
\]</span></p>
<p>再考虑 <span class="math inline">\(x\)</span> 子树内存在父子关系。若不选 <span class="math inline">\(x\)</span>，其儿子 <span class="math inline">\(y\)</span> 的 <span class="math inline">\(f_y\)</span> 至多选一个；若选 <span class="math inline">\(x\)</span>，则其儿子的 <span class="math inline">\(g_y\)</span> 至多选一个。相加即可。</p>
<p>从 <span class="math inline">\(g_y\)</span> 到 <span class="math inline">\(f_x\)</span> 时，对于每个儿子 <span class="math inline">\(y\)</span>，若子树选了空集，那么选了 <span class="math inline">\(x\)</span> 也不构成父子关系，所以应该加 <span class="math inline">\(g_y - 1\)</span>。</p>
<p><span class="math display">\[
g_x = \sum_{y \in \mathrm{son}(x)} (f_y + g_y - 1)
\]</span></p>
<p>最后输出 <span class="math inline">\(f_1 + g_1\)</span> 即可。</p>
<h3 id="代码-3">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ver[N];</span><br><span class="line"><span class="type">int</span> fa[N],n;</span><br><span class="line">ll f[N],g[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ver[i].<span class="built_in">clear</span>(),</span><br><span class="line">        fa[i]=<span class="number">0</span>,</span><br><span class="line">        f[i]=g[i]=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    f[x]=<span class="number">1</span>;</span><br><span class="line">    g[x]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y:ver[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        f[x]=(f[x]*f[y])%mod;</span><br><span class="line">        g[x]=(g[x]+g[y]+f[y]+mod<span class="number">-1ll</span>)%mod;</span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=(f[x]+<span class="number">1ll</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="type">int</span> root=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)&#123;</span><br><span class="line">        x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">        ver[x].<span class="built_in">emplace_back</span>(y);</span><br><span class="line">        ver[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,(f[<span class="number">1</span>]+g[<span class="number">1</span>])%mod);</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;order.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;order.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="f.-sasha-and-the-wedding-binary-search-tree">F. Sasha and the Wedding Binary Search Tree</h2>
<h3 id="简要翻译-4">简要翻译</h3>
<p>给定一颗二叉搜索树（BST）和值域 <span class="math inline">\([1, C]\)</span>,其中一些节点的权值未定，权值可以重复，求不同的 BST 方案数。 只要有一个节点的权值不同，就认为是不同的方案。</p>
<h3 id="思路分析">思路分析</h3>
<p>对 BST 中序遍历，应该得到一个非严格递增的序列 <span class="math inline">\(a\)</span>。</p>
<p>所以对于序列一段未定的权值，它们应该是非严格递增的。</p>
<p>对于一段未定权值，如果两端的确定权值为 <span class="math inline">\(a_l, a_r\)</span>，则相当于在 <span class="math inline">\([a_l, a_r]\)</span> 中选 <span class="math inline">\((r-l-1)\)</span> 个数。</p>
<p>权值可以重复，应用隔板法可以得到方案数应为</p>
<p><span class="math display">\[
\binom{a_r - a_l + 1 + r - l - 1}{r - l - 1}
\]</span></p>
<p>对于序列两端的未定权值，设 <span class="math inline">\(a_0 = 1, a_{n+1} = C\)</span> 即可。</p>
<p>因为 <span class="math inline">\(a_r - a_l\)</span> 和 <span class="math inline">\(C\)</span> 同阶，不能预处理阶乘来计算组合数。</p>
<p>（这里想了好久怎么办）</p>
<p>最后发现由于 <span class="math inline">\(\sum (r - l) = n + 1\)</span>，所以可以用朴素的 <span class="math inline">\(\Theta(m)\)</span> 方法求 <span class="math inline">\(\binom{n}{m}\)</span>，总复杂度为 <span class="math inline">\(\Theta(n)\)</span>。</p>
<p>至于取模，用 <span class="math inline">\(x^{-1} \equiv x^{p-2} \bmod p\)</span> 即可。</p>
<p>时间复杂度 <span class="math inline">\(\Theta(n)\)</span>。</p>
<h3 id="代码-4">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500010</span>;</span><br><span class="line"><span class="type">const</span> ll mod=<span class="number">998244353</span>;</span><br><span class="line"><span class="type">int</span> lc[N],rc[N],val[N];</span><br><span class="line"><span class="type">int</span> a[N],num;</span><br><span class="line"><span class="type">int</span> n;ll inf;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        lc[i]=rc[i]=<span class="number">-1</span>,</span><br><span class="line">        val[i]=<span class="number">-1</span>,</span><br><span class="line">        a[i]=<span class="number">0</span>;</span><br><span class="line">    num=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(~lc[x])<span class="built_in">dfs</span>(lc[x]);</span><br><span class="line">    a[++num]=val[x];</span><br><span class="line">    <span class="keyword">if</span>(~rc[x])<span class="built_in">dfs</span>(rc[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">qpow</span><span class="params">(ll x,ll y)</span></span>&#123;</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(;y;y&gt;&gt;=<span class="number">1ll</span>,x=(x*x)%mod)</span><br><span class="line">        <span class="keyword">if</span>(y&amp;<span class="number">1ll</span>)</span><br><span class="line">            ans=(ans*x)%mod;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">C</span><span class="params">(ll n,ll m)</span></span>&#123;<span class="comment">//(n(n-1)(n-2)...(n-m+1))/(m!)</span></span><br><span class="line">    ll p=<span class="number">1</span>,q=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i=<span class="number">1</span>;i&lt;=m;++i)</span><br><span class="line">        p=(p*(n+<span class="number">1</span>-i))%mod,</span><br><span class="line">        q=(q*i)%mod;</span><br><span class="line">    <span class="keyword">return</span> p*<span class="built_in">qpow</span>(q,mod<span class="number">-2</span>)%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();inf=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        lc[i]=<span class="built_in">read</span>(),</span><br><span class="line">        rc[i]=<span class="built_in">read</span>(),</span><br><span class="line">        val[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    ll ans=<span class="number">1</span>;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1</span>;a[n+<span class="number">1</span>]=inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,lst=<span class="number">0</span>;i&lt;=n+<span class="number">1</span>;++i)</span><br><span class="line">        <span class="keyword">if</span>(~a[i])&#123;</span><br><span class="line">            ans=ans*<span class="built_in">C</span>(a[i]-a[lst]+i-lst<span class="number">-1ll</span>,i-lst<span class="number">-1ll</span>)%mod;</span><br><span class="line">            lst=i;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;order.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;order.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 936 (Div. 2) Solution</title>
    <url>/2024/03/23/Codeforces-Round-936-Div-2-Solution/</url>
    <content><![CDATA[<p>目前进度：</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 15%" />
<col style="width: 15%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">E</th>
<th style="text-align: center;">F</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved later</td>
<td style="text-align: center;">solved later</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="a.-median-of-an-array">A. Median of an Array</h2>
<h3 id="简要翻译">简要翻译</h3>
<p>给定一个数列 <span class="math inline">\(a\)</span>， 每次操作可以将某个数 <span class="math inline">\(+1\)</span>，求使中位数变大的最少操作数。</p>
<h3 id="思路解析">思路解析</h3>
<p>排序后考虑中位数及其右侧，让中位数 <span class="math inline">\(+1\)</span> 必须让与中位数相等的数都 <span class="math inline">\(+1\)</span>。</p>
<h3 id="代码">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> a[N], n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> p = (n - <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;1\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = p; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span>(a[i] == a[p])</span><br><span class="line">                ans++;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="b.-maximum-sum">B. Maximum Sum</h2>
<h3 id="简要翻译-1">简要翻译</h3>
<p>给定一个序列 <span class="math inline">\(a\)</span>，每次可以将一个子段的和（可以为空，此时和为 <span class="math inline">\(0\)</span>）插入 <span class="math inline">\(a\)</span> 中，求恰好 <span class="math inline">\(k\)</span> 次操作后序列和的最大值。</p>
<h3 id="思路解析-1">思路解析</h3>
<p>设 <span class="math inline">\(a\)</span> 的最大子段和为 <span class="math inline">\(x\)</span>，那每一步可以将 <span class="math inline">\(x\)</span> 插入到最大子段的旁边，新的最大字段和变为 <span class="math inline">\(2x\)</span>。</p>
<p>这样操作 <span class="math inline">\(k\)</span> 次，获得的增量为 <span class="math inline">\(x \times (2^k - 1)\)</span>。<span class="math inline">\(k\)</span> 不大，所以可以不用快速幂。</p>
<h3 id="代码-1">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line">ll a[N], n, k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">    ll sum = <span class="number">0</span>, ans = <span class="number">0</span>, asum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">        sum += a[i];</span><br><span class="line">        asum += a[i];</span><br><span class="line">        <span class="keyword">if</span>(sum &lt; <span class="number">0</span>)</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, sum);</span><br><span class="line">    &#125;</span><br><span class="line">    asum %= mod;</span><br><span class="line">    asum = (asum + mod) % mod;</span><br><span class="line">    ans %= mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)&#123;</span><br><span class="line">        asum = (asum + ans) % mod;</span><br><span class="line">        ans = (ans &lt;&lt; <span class="number">1ll</span>) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, asum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="c.-tree-cutting">C. Tree Cutting</h2>
<h3 id="简要翻译-2">简要翻译</h3>
<p>给定一棵树，要求切掉 <span class="math inline">\(k\)</span> 条边，求剩下的连通块最小值的最大值。</p>
<h3 id="思路解析-2">思路解析</h3>
<p>最小连通块的最大值，听着就很像二分。那么考虑二分答案，转化为能不能凑出 <span class="math inline">\(k + 1\)</span> 块大小为 <span class="math inline">\(lim\)</span> 的连通块。</p>
<p>设 <span class="math inline">\(size_x\)</span> 为 <span class="math inline">\(x\)</span> 子树内大小为 <span class="math inline">\(x\)</span> 的连通块个数，<span class="math inline">\(rest_x\)</span> 表示 <span class="math inline">\(x\)</span> 所在的连通块的大小。</p>
<p>对于一个待确定的连通块，如果它大小已经到达 <span class="math inline">\(lim\)</span>，那么再合并其他的散点对于凑出答案不会更优。</p>
<p>所以在 <span class="math inline">\(rest_x \ge lim\)</span> 时就断开即可。</p>
<p>首先有 <span class="math inline">\(size_x = \sum_{y} size_y\)</span>，<span class="math inline">\(rest_x = \sum_{y} rest_x\)</span>。</p>
<p>如果 <span class="math inline">\(rest_x \ge lim\)</span>，则连通块在 <span class="math inline">\(x\)</span> 处就可以断开，将 <span class="math inline">\(size_x + 1\)</span>，并将 <span class="math inline">\(rest_x\)</span> 清零。</p>
<p>赛时写法略有不同，但效果相同。</p>
<p>时间复杂度 <span class="math inline">\(\Theta(N \lg N)\)</span>。</p>
<h3 id="代码-2">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ver[N];</span><br><span class="line"><span class="type">int</span> res[N], siz[N];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> fa, <span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    siz[x] = <span class="number">0</span>; res[x] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y : ver[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(y == fa) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y, x, lim);</span><br><span class="line">        siz[x] += siz[y];</span><br><span class="line">        <span class="keyword">if</span>(res[y] &gt;= lim)&#123;</span><br><span class="line">            siz[x]++;</span><br><span class="line">            res[y] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[x] += res[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>, <span class="number">0</span>, lim);</span><br><span class="line">    <span class="keyword">if</span>(res[<span class="number">1</span>] &gt;= lim)</span><br><span class="line">        siz[<span class="number">1</span>]++;</span><br><span class="line">    <span class="keyword">return</span> siz[<span class="number">1</span>] &gt; m;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        ver[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, x, y; i &lt; n; ++i)&#123;</span><br><span class="line">        x = <span class="built_in">read</span>(); y = <span class="built_in">read</span>();</span><br><span class="line">        ver[x].<span class="built_in">emplace_back</span>(y);</span><br><span class="line">        ver[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n, mid, ans;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">chk</span>(mid))</span><br><span class="line">            l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="d.-birthday-gift">D. Birthday Gift</h2>
<h3 id="简要翻译-3">简要翻译</h3>
<p>有一个数列 <span class="math inline">\(a\)</span>，现在将其分为 <span class="math inline">\(k\)</span> 个不相交区间，同时 <span class="math inline">\(k\)</span> 个区间的并为 <span class="math inline">\([1, n]\)</span>。</p>
<p>需要满足：<span class="math inline">\((a_{l_1} \oplus a_{l_1 + 1} \oplus \ldots \oplus a_{r_1}) | (a_{l_2} \oplus a_{l_2 + 1} \oplus \ldots \oplus a_{r_2}) | \ldots | (a_{l_k} \oplus a_{l_k + 1} \oplus \ldots \oplus a_{r_k}) \le x\)</span>。</p>
<p>求 <span class="math inline">\(k\)</span> 的最大值。</p>
<h3 id="思路解析-3">思路解析</h3>
<p>先分析一下不等式的性质。设 <span class="math inline">\(S_i = a_1 \oplus a_2 \oplus \ldots \oplus a_i\)</span>。</p>
<p>同时考虑到 <span class="math inline">\(r_i + 1 = l_{i + 1}, l_1 - 1 = 0, r_k = n\)</span>。</p>
<p>则不等式左侧变为 <span class="math inline">\(A = (S_{r_1}) | (S_{r_1} \oplus S_{r_2}) | \ldots | (S_{r_{k-1}} \oplus S_{n})\)</span>。</p>
<p>再来看单独的一位上如何限制。</p>
<p>如果 <span class="math inline">\(A = 0\)</span>，那么 <span class="math inline">\(S_{r_1} = 0, (S_{r_1} \oplus S_{r_2}) = 0 \Rightarrow S_{r_2} = 0\)</span>。 稍加分析，这一关系可以推至任意 <span class="math inline">\(S_{r_i}\)</span>。</p>
<p>所以 <span class="math inline">\(A = 0\)</span> 时一定有 <span class="math inline">\(S_{r_1} = S_{r_2} = \ldots = S_{n} = 0\)</span>。</p>
<p>考虑其逆否命题，若 <span class="math inline">\(S_{r_1}, S_{r_2}, \ldots, S_{n}\)</span> 中有至少一个值为 <span class="math inline">\(1\)</span>，则有 <span class="math inline">\(A = 1\)</span>。</p>
<p>所以如果 <span class="math inline">\(x\)</span> 的第 <span class="math inline">\(k\)</span> 位为 <span class="math inline">\(0\)</span>，我们只能选则 <span class="math inline">\(S_p\)</span> 第 <span class="math inline">\(k\)</span> 位为 <span class="math inline">\(0\)</span> 的 <span class="math inline">\(p\)</span> 构成序列 <span class="math inline">\(r\)</span>。</p>
<p>在推导过程中，可以发现 <span class="math inline">\(S_n\)</span> 是必选项，所以如果 <span class="math inline">\(S_n\)</span> 第 <span class="math inline">\(k\)</span> 位为 <span class="math inline">\(1\)</span> 时 <span class="math inline">\(A = 1\)</span>，有 <span class="math inline">\(A \ge S_n\)</span>。</p>
<p>直接的写法不会，想了一个二分答案，看我们能不能选出 <span class="math inline">\(lim\)</span> 个右端点构成 <span class="math inline">\(r\)</span>。</p>
<p>设当前在考虑第 <span class="math inline">\(k\)</span> 位，当前位为 <span class="math inline">\(0\)</span> 的 <span class="math inline">\(S\)</span> 构成的集合为 <span class="math inline">\(\mathrm{now}\)</span>, 高位符合要求的集合为 <span class="math inline">\(\mathrm{bit}\)</span>。</p>
<p>统计 <span class="math inline">\(\mathrm{bit}_i\ \&amp;\ \mathrm{now}_i = 1\)</span> 的位置个数 <span class="math inline">\(t\)</span>。</p>
<p>如果 <span class="math inline">\(x\)</span> 第 <span class="math inline">\(k\)</span> 位为 <span class="math inline">\(1\)</span> 而 <span class="math inline">\(t \ge lim\)</span>，说明此位选 <span class="math inline">\(0\)</span> 就可以满足要求，而低位选出的值无论是 <span class="math inline">\(0\)</span> 是 <span class="math inline">\(1\)</span> 都不影响 <span class="math inline">\(A &lt; x\)</span>；</p>
<p>如果 <span class="math inline">\(t &lt; lim\)</span>，则考虑不应用 <span class="math inline">\(\mathrm{now}\)</span> 的限制，这一位在低位的计算中会取 <span class="math inline">\(1\)</span>。</p>
<p>如果 <span class="math inline">\(x\)</span> 第 <span class="math inline">\(k\)</span> 位为 <span class="math inline">\(0\)</span>，因为已经构造的 <span class="math inline">\(A\)</span> 的高位和 <span class="math inline">\(x\)</span> 相等，所以此位只能选 <span class="math inline">\(0\)</span>。将 <span class="math inline">\(\mathrm{bit}\)</span> 与 <span class="math inline">\(\mathrm{now}\)</span> 求交集即可。</p>
<p>什么时候无解呢？上面有 <span class="math inline">\(A \ge S_n\)</span>，所以 <span class="math inline">\(S_n &gt; x\)</span> 时无解；反之，选取区间 <span class="math inline">\([1, n]\)</span> 一定成立，答案至少为 <span class="math inline">\(1\)</span>。</p>
<p>时间复杂度 <span class="math inline">\(O(N\lg N \lg X)\)</span>。</p>
<h3 id="代码-3">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bitset&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,x;</span><br><span class="line"><span class="type">int</span> sum[N];</span><br><span class="line">bitset&lt;N&gt; bit,now;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk</span><span class="params">(<span class="type">int</span> lim)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        bit.<span class="built_in">set</span>(i, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">30</span>, cnt = <span class="number">0</span>; ~k; cnt = <span class="number">0</span>, --k)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            now.<span class="built_in">set</span>(i, !((sum[i] &gt;&gt; k) &amp; <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            cnt += bit[i] &amp; now[i];</span><br><span class="line">        <span class="keyword">if</span>((x &gt;&gt; k) &amp; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= lim &amp;&amp; (bit[n] &amp; now[n]))<span class="comment">//sn = 0, 可以选出 lim 个</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt &lt; lim || !(bit[n] &amp; now[n]))<span class="comment">//sn = 1 或者选不出 lim 个了</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            bit = bit &amp; now;<span class="comment">//应用此位为 0 的集合约束</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); x = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] ^ <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(sum[n] &gt; x)&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n, mid, ans;</span><br><span class="line">    <span class="keyword">while</span>(l &lt;= r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">chk</span>(mid))</span><br><span class="line">            l = mid + <span class="number">1</span>, ans = mid;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="e.-girl-permutation">E. Girl Permutation</h2>
<h3 id="简要翻译-4">简要翻译</h3>
<p>对于一个排列，给定它的前缀最大值的位置序列、后缀最大值的位置序列，求可能的排列的数量。</p>
<p>前缀最大值的位置序列 <span class="math inline">\(p\)</span>，指的是序列中的一个值 <span class="math inline">\(p_i\)</span> 对应 <span class="math inline">\(v_{p_i}\)</span> 是 <span class="math inline">\(v_1, v_2, \ldots, v_{p_i}\)</span> 中的最大值。</p>
<p>后缀最大值类似。</p>
<h3 id="思路解析-4">思路解析</h3>
<p>纯纯数学题。赛场上没想完，亏了。</p>
<p>设前缀最大值的位置序列为 <span class="math inline">\(a_1, a_2, \ldots, a_{m_1}\)</span>，后缀最大值的位置序列为 <span class="math inline">\(b_1, b_2, \ldots, b_{m_2}\)</span>。</p>
<p>根据定义不难得出 <span class="math inline">\(a_1 = 1, b_{m_1} = n\)</span>。同时 <span class="math inline">\(v_p = n\)</span> 的位置应该既是 <span class="math inline">\(a_{m_1}\)</span> 又是 <span class="math inline">\(b_1\)</span>。有一条不满足，则答案为 <span class="math inline">\(0\)</span>。</p>
<p>显然前缀最大值和后缀最大值相交于 <span class="math inline">\(v_p = n\)</span> 而不会交叉，所以两边可以分开计算。</p>
<p>同时我们可以把任意 <span class="math inline">\(m_1 - 1\)</span> 个数放在 <span class="math inline">\(n\)</span> 的左边，然后让它们按规则排列。这样答案就有一个基数 <span class="math inline">\(\binom{n - 1}{m_1 - 1}\)</span>。</p>
<p>先算左边。设 <span class="math inline">\(f_i\)</span> 为序列 <span class="math inline">\(1 \sim i\)</span> 位置上的方案数。不妨先假设值域为 <span class="math inline">\([1, m_1]\)</span>。</p>
<p>如果 <span class="math inline">\(i\)</span> 是某个 <span class="math inline">\(a_j\)</span>，那么 <span class="math inline">\(v_i\)</span> 在前 <span class="math inline">\(i\)</span> 个数排序后必须处于末尾，<span class="math inline">\(f_i = f_{i-1}\)</span>；</p>
<p>否则 <span class="math inline">\(v_i\)</span> 在前 <span class="math inline">\(i\)</span> 个数排序后不能处于末尾，有 <span class="math inline">\(i - 1\)</span> 个位置可供选择，<span class="math inline">\(f_i = f_{i-1} \times (i - 1)\)</span>。</p>
<p>对后缀最大值的处理类似，不再赘述。</p>
<p>时间复杂度 <span class="math inline">\(\Theta(N)\)</span>。</p>
<h3 id="代码-4">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>())f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>())res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len;<span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op = <span class="built_in">getc</span>(); <span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">0</span>; <span class="built_in">ischr</span>(op); op = <span class="built_in">getc</span>())s[len++] = op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">1000000007</span>;</span><br><span class="line">ll fac[N], inv[N], invfac[N];</span><br><span class="line"><span class="type">int</span> pre[N], suf[N], n, m1, m2;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fac[<span class="number">0</span>] = fac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    inv[<span class="number">0</span>] = inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    invfac[<span class="number">0</span>] = invfac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; N; ++i)&#123;</span><br><span class="line">        fac[i] = (fac[i - <span class="number">1</span>] * i) % mod;</span><br><span class="line">        inv[i] = (mod - mod / i) * inv[mod % i] % mod;</span><br><span class="line">        invfac[i] = (invfac[i - <span class="number">1</span>] * inv[i]) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">binom</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fac[n]*invfac[m]%mod*invfac[n-m]%mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m1 = <span class="built_in">read</span>();</span><br><span class="line">    m2 = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m1; ++i)</span><br><span class="line">        pre[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m2; ++i)</span><br><span class="line">        suf[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">if</span>(pre[<span class="number">1</span>] != <span class="number">1</span> || pre[m1] != suf[<span class="number">1</span>] || suf[m2] != n)&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;0\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, p = <span class="number">1</span>; i &lt;= pre[m1]; ++i)</span><br><span class="line">    <span class="keyword">if</span>(i != pre[p])</span><br><span class="line">        ans = ans * (i<span class="number">-1ll</span>) % mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p++;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n, p = m2; i &gt;= suf[<span class="number">1</span>]; --i)</span><br><span class="line">    <span class="keyword">if</span>(i != suf[p])</span><br><span class="line">        ans = ans * (n - i) % mod;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        p--;</span><br><span class="line">    ans = ans * <span class="built_in">binom</span>(n - <span class="number">1</span>, pre[m1] - <span class="number">1</span>) % mod;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="f.-title">F. Title</h2>
<h3 id="简要翻译-5">简要翻译</h3>
<p>给定一个序列 <span class="math inline">\(a\)</span>，每次查询一个区间，询问区间中子序列的数量，要求子序列中前一个数是后一个数的约数。</p>
<h3 id="思路解析-5">思路解析</h3>
<p>这题 6s 时限，看上去会略超过 <span class="math inline">\(10^8\)</span> 计算量。</p>
<p>区间用类扫描线的方法转化，在右端点加入集合的时候查询。</p>
<p>设 <span class="math inline">\(s_i\)</span> 表示从 <span class="math inline">\(i\)</span> 开始，到目前的右界 <span class="math inline">\(r\)</span> 中合法子序列的数量。</p>
<p>当右界从 <span class="math inline">\(r - 1\)</span> 移动到 <span class="math inline">\(r\)</span> 时，所有新增的子序列必须以 <span class="math inline">\(r\)</span> 结尾。</p>
<p>那么新增序列去掉 <span class="math inline">\(r\)</span> 之后的末尾，它的值一定是 <span class="math inline">\(v_r\)</span> 的约数。</p>
<p>我们可以将标记打在 <span class="math inline">\(\{p | (v_p | v_r)\}\)</span> 上，这时候 <span class="math inline">\(p\)</span> 就是新增序列的等效末尾，再用它来向前更新。</p>
<p>更新 <span class="math inline">\(s_i\)</span> 之后就可以查询了。这里因为复杂度比较高，使用了树状数组来降低常数。</p>
<p>计算所有的 <span class="math inline">\(r\)</span> 一共更新了多少个值，可以反过来算每个 <span class="math inline">\(v_i\)</span> 的倍数出现的次数和。</p>
<p>因为 <span class="math inline">\(v\)</span> 构成排列，这个数应当等于 <span class="math inline">\((\frac{N}{1} + \frac{N}{2} + \ldots + \frac{N}{N})\)</span>，即 <span class="math inline">\(N\ln N\)</span>。</p>
<p>所以总复杂度为 <span class="math inline">\(O(N\ln N \lg^2 N)\)</span>，能卡过也是神奇。</p>
<h3 id="代码-5">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len;<span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op = <span class="built_in">getc</span>(); <span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">0</span>; <span class="built_in">ischr</span>(op); op = <span class="built_in">getc</span>()) s[len++] = op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="keyword">typedef</span> pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt; pii;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tp, <span class="type">int</span> LEN&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BIT</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">resize</span><span class="params">(<span class="type">int</span> len)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, Tp v)</span></span>;</span><br><span class="line">    <span class="function">Tp <span class="title">ask</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Tp c[LEN];</span><br><span class="line">    <span class="type">int</span> c_len;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tp, <span class="type">int</span> LEN&gt;</span><br><span class="line"><span class="type">void</span> BIT&lt;Tp, LEN&gt;::<span class="built_in">clear</span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">0</span>; x &lt;= c_len; x++) c[x] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tp, <span class="type">int</span> LEN&gt;</span><br><span class="line"><span class="type">void</span> BIT&lt;Tp, LEN&gt;::<span class="built_in">resize</span>(<span class="type">int</span> len)&#123;</span><br><span class="line">    c_len = len;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tp, <span class="type">int</span> LEN&gt;</span><br><span class="line"><span class="type">void</span> BIT&lt;Tp, LEN&gt;::<span class="built_in">add</span>(<span class="type">int</span> x, Tp v)&#123;</span><br><span class="line">    <span class="keyword">for</span>(; x &lt;= c_len; x += x &amp; -x) c[x] += v;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Tp, <span class="type">int</span> LEN&gt;</span><br><span class="line">Tp BIT&lt;Tp, LEN&gt;::<span class="built_in">ask</span>(<span class="type">int</span> x)&#123;</span><br><span class="line">    <span class="function">Tp <span class="title">ans</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(; x; x -= x &amp; -x) ans += c[x];</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line">BIT&lt;ll, N&gt; B;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; divend[N];</span><br><span class="line">vector&lt;pii&gt; query[N];</span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; Q;</span><br><span class="line"><span class="type">int</span> per[N], pos[N], n, m;</span><br><span class="line">ll tag[N], ans[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> x = <span class="number">1</span>; x &lt; N; x++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y = x &lt;&lt; <span class="number">1</span>; y &lt; N; y += x)</span><br><span class="line">        divend[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>();</span><br><span class="line">    m = <span class="built_in">read</span>();</span><br><span class="line">    B.<span class="built_in">resize</span>(n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        query[i].<span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        pos[per[i] = <span class="built_in">read</span>()] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, l, r; i &lt;= m; ++i)&#123;</span><br><span class="line">        l = <span class="built_in">read</span>();</span><br><span class="line">        r = <span class="built_in">read</span>();</span><br><span class="line">        query[r].<span class="built_in">emplace_back</span>(<span class="built_in">make_pair</span>(l, i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        Q.<span class="built_in">push</span>(i);</span><br><span class="line">        tag[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!Q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="type">int</span> x = Q.<span class="built_in">top</span>(); Q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> y : divend[per[x]])</span><br><span class="line">            <span class="keyword">if</span>(pos[y] &lt; x)&#123;</span><br><span class="line">                <span class="keyword">if</span>(!tag[pos[y]])</span><br><span class="line">                    Q.<span class="built_in">push</span>(pos[y]);</span><br><span class="line">                tag[pos[y]] += tag[x];</span><br><span class="line">            &#125;</span><br><span class="line">            B.<span class="built_in">add</span>(x, tag[x]);</span><br><span class="line">            tag[x] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> [l, id] : query[i])</span><br><span class="line">            ans[id] = B.<span class="built_in">ask</span>(i) - B.<span class="built_in">ask</span>(l - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, ans[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="后记">后记</h2>
<p>这把 D 题做完还有 30min，以为自己不能拿下很数学的 E 题，遂开摆。最后发现自己离 1900 只有一步之遥，感觉很后悔。</p>
<p>最近作业压力太大，Lab 和 Proj 堆了一个又一个，感觉清明之前不完成的话会度过一个很不愉快的假期。</p>
<p>转念一想，清明可以和烧烤群的各位面基，还是很期待的。</p>
<p>加把劲吧。</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Discrete Mathematics Note Chapter 1</title>
    <url>/2024/04/20/Discrete-Mathematics-Note-Chapter-1/</url>
    <content><![CDATA[<h1 id="logic-and-proofs">Logic and Proofs</h1>
<span id="more"></span>
<h2 id="propositional-logic">Propositional Logic</h2>
<h3 id="proposition">Proposition</h3>
<p>Definition: A <strong>proposition</strong> is a declarative sentence that is either <strong>true</strong> or <strong>false</strong>, but not both.</p>
<h3 id="truth-value">Truth value</h3>
<p>Big <span class="math inline">\(\mathrm{T}\)</span> for <strong>true</strong> and big <span class="math inline">\(\mathrm{F}\)</span> for <strong>false</strong>.</p>
<h3 id="logical-operators-connectives">Logical operators (Connectives)</h3>
<h4 id="negation-not">Negation (Not)</h4>
<p>The <strong>negation</strong> of <span class="math inline">\(p\)</span>, <span class="math inline">\(\lnot p\)</span>, is the proposition "It is not the case that <span class="math inline">\(p\)</span>."</p>
<h4 id="conjunction-and">Conjunction (And)</h4>
<p>The <strong>conjunction</strong> of <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, is the proposition "<span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>."</p>
<h4 id="disjunction-inclusive-or">Disjunction (Inclusive Or)</h4>
<p>The <strong>disjunction</strong> of <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, is the proposition "<span class="math inline">\(p\)</span> or <span class="math inline">\(q\)</span>."</p>
<h4 id="exclusive-or-xor">Exclusive Or (Xor)</h4>
<p>The <strong>exclusive or</strong> of <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, is the proposition "<span class="math inline">\(p\)</span> or <span class="math inline">\(q\)</span>, but not both."</p>
<h4 id="conditional-operator-if-then">Conditional Operator (If-then)</h4>
<p>The <strong>conditional statement</strong> of <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, is the proposition "if <span class="math inline">\(p\)</span>, then <span class="math inline">\(q\)</span>."</p>
<p><span class="math inline">\(p \rightarrow q\)</span> is false <strong>only</strong> when <span class="math inline">\(p\)</span> is true and <span class="math inline">\(q\)</span> is false.</p>
<p>Converse: <span class="math inline">\(q \rightarrow p\)</span> Inverse: <span class="math inline">\(\lnot p \rightarrow \lnot q\)</span> Contrapositive: <span class="math inline">\(\lnot q \rightarrow \lnot p\)</span>.</p>
<h4 id="biconditional-operator">Biconditional Operator</h4>
<p>The <strong>biconditional statement</strong> of <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span>, is the proposition "<span class="math inline">\(p\)</span> if and only if <span class="math inline">\(q\)</span>."</p>
<h4 id="precedence">Precedence</h4>
<p><span class="math inline">\(\lnot &gt; \land &gt; \lor &gt; \rightarrow &gt; \leftrightarrow\)</span>.</p>
<h3 id="truth-table">Truth Table</h3>
<p>Columns display variables and propositions; Rows display different cases.</p>
<p>For <span class="math inline">\(n\)</span> variables, there will be <span class="math inline">\(2^n\)</span> rows.</p>
<h2 id="applications-of-propositional-logic">Applications of Propositional Logic</h2>
<p>System specification: Express English sentences in logical statements.</p>
<p>Consistent system specification: A list of propositions is <strong>consistent</strong> if it is possible to assign truth values to the proposition variables so that each proposition is true.</p>
<h2 id="propositional-equivalences">Propositional Equivalences</h2>
<h3 id="compound-propositions">Compound Propositions</h3>
<p>​ <strong>Tautology</strong>: statement that is <strong>always</strong> true.</p>
<p>​ <strong>Contradiction</strong>: statement that is <strong>always</strong> false.</p>
<p>​ <strong>Contingency</strong>: its value depends.</p>
<h3 id="logical-equivalence">Logical Equivalence</h3>
<p>Propositions <span class="math inline">\(p\)</span> and <span class="math inline">\(q\)</span> are called <strong>logically equivalent</strong> if <span class="math inline">\(p \leftrightarrow q\)</span> is a tautology. This case can be denoted as <span class="math inline">\(p \Leftrightarrow q\)</span>, or <span class="math inline">\(p \equiv q\)</span>.</p>
<h3 id="already-proved-equivalence">Already proved equivalence</h3>
<table>
<colgroup>
<col style="width: 75%" />
<col style="width: 24%" />
</colgroup>
<thead>
<tr class="header">
<th>Laws</th>
<th>Law Names</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(p \land \mathrm{\mathrm{T}} \equiv p\)</span>, <span class="math inline">\(p \lor \mathrm{F} \equiv p\)</span></td>
<td>Identity laws</td>
</tr>
<tr class="even">
<td><span class="math inline">\(p \land \mathrm{F} \equiv \mathrm{F}\)</span>, <span class="math inline">\(p \lor \mathrm{T} \equiv \mathrm{T}\)</span></td>
<td>Domination laws</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(p \lor p \equiv p, p \land p \equiv p\)</span></td>
<td>Idempotent laws</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\lnot (\lnot p) \equiv p\)</span></td>
<td>Double negation law</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(p \land q \equiv q \land p, \\ p \lor q \equiv q \lor p\)</span></td>
<td>Commutative laws</td>
</tr>
<tr class="even">
<td><span class="math inline">\(p \lor (q \lor r) \equiv (p \lor q) \lor r,\\ p \land (q \land r) \equiv (p \land q) \land r\)</span></td>
<td>Associative laws</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(p \lor (q \land r) \equiv (p \lor q) \land (p \lor r),\\ p \land (q \lor r) \equiv (p \land q) \lor (p \land r)\)</span></td>
<td>Distributive laws</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\lnot (p \land q) \equiv \lnot p \lor \lnot q,\\ \lnot (p \lor q) \equiv \lnot p \land \lnot q\)</span></td>
<td>De Morgan's laws</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(p \lor (p \land q) \equiv p,\\ p \land (p \lor q) \equiv p\)</span></td>
<td>Absorption laws</td>
</tr>
<tr class="even">
<td><span class="math inline">\(p \lor \lnot p \equiv \mathrm{T}, p \land \lnot p \equiv \mathrm{F}\)</span></td>
<td>Negation laws</td>
</tr>
</tbody>
</table>
<p>The operator <span class="math inline">\(\downarrow\)</span> is called <strong>Peirce arrow</strong>, and stands for <span class="math inline">\(Nor\)</span> operation. It's functional complete, and we have:</p>
<ol type="1">
<li><span class="math inline">\(p \downarrow p \equiv \lnot p\)</span>.</li>
<li><span class="math inline">\((p\downarrow q) \downarrow (p \downarrow q) \equiv p \lor q\)</span>.</li>
<li><span class="math inline">\((p \downarrow p) \downarrow (q \downarrow q) \equiv p \land q\)</span>.</li>
</ol>
<h3 id="propositional-satisfiability">Propositional Satisfiability</h3>
<p>A compound proposition is <strong>satisfiable</strong> if there is an assignment to all variables that make it true.</p>
<p>If it is a contradiction, it is called <strong>unsatisfiable</strong>.</p>
<h2 id="predicates-and-quantifiers">Predicates and Quantifiers</h2>
<h3 id="predicate">Predicate</h3>
<p>A <strong>predicate</strong> is a statement that contains variables. Once the variables' values are set, its truth value is set too.</p>
<h3 id="universal-quantification">Universal Quantification</h3>
<p>A <strong>universal quantification</strong> of <span class="math inline">\(P(x)\)</span>, denoted by <span class="math inline">\(\forall x\ P(x)\)</span>, is the statement that "<span class="math inline">\(P(x)\)</span> is true for all x in the domain."</p>
<p>It's equivalent of <span class="math inline">\(\bigcap\limits_{x \in D} P(x)\)</span>.</p>
<h3 id="existential-quantification">Existential Quantification</h3>
<p>An <strong>existential quantification</strong> of <span class="math inline">\(P(x)\)</span>, denoted by <span class="math inline">\(\exists x\ P(x)\)</span>, is the statement that "<span class="math inline">\(P(x)\)</span> is true for at least one x in the domain".</p>
<p>It's equivalent of <span class="math inline">\(\bigcup\limits_{x \in D} P(x)\)</span>.</p>
<h3 id="binding-variables">Binding Variables</h3>
<p>A variable constrained by quantifiers is called <strong>bound variable</strong>. Otherwise, it's called <strong>Free variable</strong>.</p>
<p>Constants are not in any of the two types.</p>
<h3 id="logical-equivalences-involving-quantifiers">Logical Equivalences Involving Quantifiers</h3>
<p>Two statements are logically equivalent <span class="math inline">\(\mathrm{iff}\)</span> they have the same truth value when predicates specified in the same set of values.</p>
<h4 id="some-useful-equivalence">Some useful equivalence</h4>
<p><span class="math inline">\(\forall x (A(x) \land B(x)) \equiv \forall x A(x) \land \forall x B(x)\)</span>.</p>
<p><span class="math inline">\(\exists x (A(x) \lor B(x)) \equiv \exists x A(x) \lor \exists x B(x)\)</span>.</p>
<p><span class="math inline">\(\lnot \forall x P(x) \equiv \exists x \lnot P(x)\)</span>.</p>
<p><span class="math inline">\(\lnot \exists x P(x) \equiv \forall x \lnot P(x)\)</span>.</p>
<p><span class="math inline">\(\forall x(P(x) \rightarrow A) \equiv \exists x P(x) \rightarrow A\)</span>.</p>
<p><span class="math inline">\(\forall x(A \rightarrow P(x)) \equiv A \rightarrow \forall x P(x)\)</span>.</p>
<h2 id="nested-quantifiers">Nested Quantifiers</h2>
<p>Two quantifiers are <strong>nested</strong> if one is within the scope of the other.</p>
<p>The order of nested quantifiers <strong>matters</strong> when they are of <strong>different</strong> types.</p>
<h2 id="rules-of-inference">Rules of Inference</h2>
<h3 id="valid-arguments">Valid Arguments</h3>
<p>An <strong>argument</strong> in propositional logic is a sequence of statements that end with a conclusion.</p>
<p><strong>Valid arguments</strong> are called proofs. <strong>Valid</strong> means the preceding statements determines the truth of the conclusion.</p>
<p>An <strong>argument form</strong> in propositional logic is a sequence of compound propositions involving propositional variables.</p>
<p><strong>Valid argument forms</strong> are those whose value is true once their premises are all true in propositional variables forms.</p>
<p>An argument's validity is identical with its form's validity.</p>
<p>To prove validity:</p>
<blockquote>
<ol type="1">
<li>Assume all premises are true</li>
<li>Use the rules of inference and logical equivalence to determine that the conclusion is true</li>
</ol>
</blockquote>
<h3 id="rules-of-inference-1">Rules of Inference</h3>
<p><strong>Rules of inference</strong> are simple argument forms whose correctness can be established with truth tables.</p>
<table>
<colgroup>
<col style="width: 56%" />
<col style="width: 43%" />
</colgroup>
<thead>
<tr class="header">
<th>Rules</th>
<th>Rule Names</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\((p\ \land\ (p\rightarrow q)) \rightarrow q\)</span></td>
<td>Modus ponens<br />(mode that affirms in Latin)</td>
</tr>
<tr class="even">
<td><span class="math inline">\((\lnot q\ \land\ (p \rightarrow q)) \rightarrow \lnot p\)</span></td>
<td>Modus tollens<br />(mode the denies in Latin)</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(((p \rightarrow q)\ \land\ (q \rightarrow r)) \rightarrow (p \rightarrow r)\)</span></td>
<td>Hypothetical Syllogism</td>
</tr>
<tr class="even">
<td><span class="math inline">\(((p \lor q) \land \lnot p) \rightarrow q\)</span></td>
<td>Disjunctive Syllogism</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(p \rightarrow (p \lor q)\)</span></td>
<td>Addition</td>
</tr>
<tr class="even">
<td><span class="math inline">\((p \land q ) \rightarrow p\)</span></td>
<td>Simplification</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(((p \lor q)\ \land\ (\lnot p \lor r)) \rightarrow (q \lor r)\)</span></td>
<td>Resolution</td>
</tr>
</tbody>
</table>
<p>Adding quantifiers, we have another table.</p>
<table>
<colgroup>
<col style="width: 69%" />
<col style="width: 30%" />
</colgroup>
<thead>
<tr class="header">
<th>Rules</th>
<th>Rule Names</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><span class="math inline">\(\dfrac{\forall x P(x)}{\therefore P(c)}\)</span></td>
<td>Universal instantiation</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\dfrac{P(c)\ \mathrm{for\ any\ } c}{\therefore \forall x P(x)}\)</span></td>
<td>Universal generalization</td>
</tr>
<tr class="odd">
<td><span class="math inline">\(\dfrac{\exists x P(x)}{\therefore P(c)\ \mathrm{for\ some\ } c}\)</span></td>
<td>Existential instantiation</td>
</tr>
<tr class="even">
<td><span class="math inline">\(\dfrac{P(c)\ \mathrm{for\ some\ } c}{\therefore \exists x P(x)}\)</span></td>
<td>Existential generalization</td>
</tr>
</tbody>
</table>
<p>If you deny the premises to prove the negation of conclusion, or affirm the conclusion to prove the premises, then you may walk in the trap of <strong>fallacy</strong>.</p>
<h2 id="introduction-of-proofs">Introduction of Proofs</h2>
<blockquote>
<p>The construction of a valid proof is an art, honed after much practice.</p>
</blockquote>
<h3 id="terms">Terms</h3>
<p>A <strong>proof</strong> is valid argument establishes the truth of a mathematical statement.</p>
<p>A <strong>theorem</strong> is a statement shown true.</p>
<p>A <strong>axiom</strong> is a statement we assume to be true.</p>
<p>A <strong>lemma</strong> is a less important theorem helpful in proving.</p>
<p>A <strong>corollary</strong> is a derived lemma from theorems.</p>
<p>A <strong>conjecture</strong> is a guess statement that is being proposed to be true. It becomes a theorem once it has been proved true.</p>
<h3 id="direct-proof">Direct Proof</h3>
<p><span class="math inline">\(\forall x (P(x) \rightarrow Q(x)) \Leftrightarrow P(c) \rightarrow Q(c)\)</span> for arbitrary <span class="math inline">\(c\)</span>.</p>
<p><span class="math inline">\(\rightarrow:\)</span> Universal instantiation</p>
<p><span class="math inline">\(\leftarrow:\)</span> Universal generalization</p>
<p>Assume <span class="math inline">\(P(x)\)</span> is true, and use rules and other theorems to reach <span class="math inline">\(Q(x)\)</span>.</p>
<h3 id="contraposition-proof">Contraposition Proof</h3>
<p><span class="math display">\[
P \rightarrow Q \equiv \lnot Q \rightarrow \lnot P
\]</span></p>
<p>So we can assume <span class="math inline">\(\lnot Q(x)\)</span> is true, and then try to reach <span class="math inline">\(\lnot P(x)\)</span>.</p>
<h3 id="vacuous-proof">Vacuous Proof</h3>
<p>If we know <span class="math inline">\(P\)</span> is false then <span class="math inline">\(P \rightarrow Q\)</span> is <strong>vacuously</strong> true.</p>
<h3 id="trivial-proof">Trivial Proof</h3>
<p>If we know <span class="math inline">\(Q\)</span> is true then <span class="math inline">\(P \rightarrow Q\)</span> is <strong>trivial</strong> true.</p>
<h3 id="contradiction">Contradiction</h3>
<p>Try to prove <span class="math inline">\(p\)</span>, we can assume <span class="math inline">\(p\)</span> is false, and then deduce <span class="math inline">\(p \rightarrow (q \vee \lnot q )\)</span>.</p>
<p>Another form: For <span class="math inline">\(p \rightarrow q\)</span>, we can assume <span class="math inline">\(\lnot q \wedge p\)</span>, and then deduce <span class="math inline">\((\lnot q \wedge p) \rightarrow (t \wedge \lnot t)\)</span>.</p>
<h3 id="proofs-of-equivalence">Proofs of Equivalence</h3>
<p>To show <span class="math inline">\(p_1, p_2, \ldots, p_n\)</span> are equivalent, we can prove that <span class="math inline">\(p_1 \rightarrow p_2 \rightarrow \cdots \rightarrow p_n\)</span>, and then prove <span class="math inline">\(p_n \rightarrow p_1\)</span>.</p>
<h2 id="proof-methods-and-strategy">Proof Methods and Strategy</h2>
<h3 id="proof-by-cases">Proof by Cases</h3>
<p>Break the premise <span class="math inline">\(p\)</span> into <span class="math inline">\(p_1, p_2, \ldots p_n\)</span>. And prove that <span class="math inline">\(p_i \rightarrow q\)</span> for all <span class="math inline">\(i\)</span>.</p>
<p>Finally we have <span class="math inline">\((\bigwedge (p_i \rightarrow q)) \leftrightarrow ((\bigvee p_i) \rightarrow q)\)</span>.</p>
<h3 id="existence-proof">Existence Proof</h3>
<p>To prove <span class="math inline">\(\exists x P(x)\)</span>.</p>
<p>Constructive</p>
<ol type="1">
<li>Establish <span class="math inline">\(P(c)\)</span> is <span class="math inline">\(\mathrm{T}\)</span> for some <span class="math inline">\(c\)</span>.</li>
<li>Use Existential Generalization, <span class="math inline">\(\exists x P(x)\)</span> is true.</li>
</ol>
<p>Nonconstructive</p>
<ol type="1">
<li>Assume no <span class="math inline">\(c\)</span> exists that <span class="math inline">\(P(c)\)</span> is <span class="math inline">\(\mathrm{T}\)</span>.</li>
<li>Find a contradiction.</li>
</ol>
<h3 id="uniqueness-proof">Uniqueness Proof</h3>
<p>To prove <span class="math inline">\(\exists x (P(x) \wedge \forall y (y \neq x \rightarrow \lnot P(y)))\)</span>.</p>
<ol type="1">
<li>Prove existence of qualified <span class="math inline">\(x\)</span>.</li>
<li>Prove that <span class="math inline">\(y \neq x \rightarrow \lnot P(y)\)</span>, or prove <span class="math inline">\((P(x) \wedge P(y)) \rightarrow x = y\)</span>.</li>
</ol>
<h3 id="backward-reasoning">Backward Reasoning</h3>
<p>To prove a statement <span class="math inline">\(q\)</span>, we try to find a provable statement <span class="math inline">\(p\)</span> that <span class="math inline">\(p \rightarrow q\)</span> holds.</p>
<p>By using this method recursively, we may finally reach those given premises.</p>
<h3 id="additional-methods-of-proofs">Additional Methods of Proofs</h3>
<ul>
<li><p>Mathematical induction</p></li>
<li><p>Structural induction</p></li>
<li><p>The Cantor diagonalization argument</p></li>
<li><p>Combinatorial proofs</p></li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Discrete Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>Codeforces Round 942 (Div. 1) Solution</title>
    <url>/2024/05/01/Codeforces-Round-942-Div-1-Solution/</url>
    <content><![CDATA[<p>菜狗的第二场 Div.1，感觉晚上临时开窍了，能上橙名。</p>
<p>场上做出了 A ~ C，同时 D 的解法已经想出来了，碍于码力没有写完。</p>
<p>后续的题稍微看下，不一定会 / 能补了。</p>
<span id="more"></span>
<h2 id="a.-permutation-counting">A. Permutation Counting</h2>
<h3 id="简要翻译">简要翻译</h3>
<p>有一副牌，点数为 <span class="math inline">\([1, n]\)</span>，有 <span class="math inline">\(a_i\)</span> 张点数为 <span class="math inline">\(i\)</span> 的牌。</p>
<p>同时可以购买任意点数的牌，购买的数量之和不超过 <span class="math inline">\(k\)</span>。</p>
<p>买完之后将牌按某种顺序排列，定义序列的分数为<strong>是 <span class="math inline">\([n]\)</span> 的排列的</strong>子区间个数。</p>
<p>求序列分数的最大值。</p>
<h3 id="思路解析">思路解析</h3>
<p>先思考如何在牌的数量固定的情况下排出最多的 <span class="math inline">\([n]\)</span> 的排列 <span class="math inline">\(c\)</span>。</p>
<p>对于两个子区间 <span class="math inline">\([i, i + n - 1]\)</span> 和 <span class="math inline">\([i + 1, i + n]\)</span>，它们如果都是 <span class="math inline">\([n]\)</span> 的排列，那么一定有 <span class="math inline">\(c_i = c_{i + n}\)</span>。</p>
<p>所以一旦确定 <span class="math inline">\(c\)</span> 的前 <span class="math inline">\(n\)</span> 个数，<span class="math inline">\(c_{i + n}\)</span> 总是可以由 <span class="math inline">\(c_i\)</span> 确定，整个序列的答案就固定了。</p>
<p>考虑一下所有牌数量都一样的时候的答案。</p>
<p>假设 <span class="math inline">\(a_1 = a_2 = \cdots = a_n = t\)</span>，那么序列总长为 <span class="math inline">\(t \times n\)</span>。</p>
<p>除去不能作为合法区间右端点的 <span class="math inline">\(n - 1\)</span> 个值，答案为 <span class="math inline">\(t \times n - n + 1\)</span>。</p>
<p>对于 <span class="math inline">\(a_i\)</span> 不相等的情况，容易想到应该让 <span class="math inline">\(a_i\)</span> 大的 <span class="math inline">\(i\)</span> 出现在序列的前面，这样向后延伸时先使用大的 <span class="math inline">\(a_i\)</span>，答案显然会更大。</p>
<p>这启发我们将 <span class="math inline">\(a_i\)</span> 从大到小排序，然后从后往前分配我们可以购买的牌。</p>
<p>假设目前还能购买 <span class="math inline">\(k\)</span> 张牌，<span class="math inline">\(a_i - a_{i + 1} = \delta\)</span>。</p>
<p>如果 <span class="math inline">\(\delta \times (n - i) \leq k\)</span>，说明第 <span class="math inline">\(i + 1 \sim n\)</span> 的位置都可以补足 <span class="math inline">\(a_i\)</span> 张牌，直接在 <span class="math inline">\(k\)</span> 中减掉即可。</p>
<p>否则，说明最终序列中不能完整地出现 <span class="math inline">\(a_{i}\)</span> 个 <span class="math inline">\([n]\)</span> 的排列，这个时候就可以直接计算：</p>
<blockquote>
<p>记 <span class="math inline">\(\delta^\prime = \lfloor \frac{k}{n - i} \rfloor, k^\prime = k - (n - i)\delta^\prime\)</span>。</p>
<p>答案的第一部分，是 <span class="math inline">\(a_{i + 1} + \delta^\prime\)</span> 个完整 <span class="math inline">\([n]\)</span> 的排列，这里的答案是 <span class="math inline">\((a_{i + 1} + \delta^\prime) \times n - n + 1\)</span>。</p>
<p>第二部分，是接下来还能在第一部分的序列后面接上 <span class="math inline">\(i + k^\prime\)</span> 张牌，每一张都能形成一个新的合法子区间，答案为 <span class="math inline">\(i + k^\prime\)</span>。</p>
<p>两部分的和就是答案。</p>
</blockquote>
<p>如果遍历完后还没有触发直接计算，说明所有的数字都可以补足为 <span class="math inline">\(a_1\)</span>，这是我们按所有牌数量一样的情况计算，答案为 <span class="math inline">\(a_{1} \times n - n + 1 + m\)</span>。</p>
<h3 id="代码">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isalpha</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">iscapitcal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;Z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isletter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isalpha</span>(op) || <span class="built_in">iscapitcal</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isletter</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len; <span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op = <span class="built_in">getc</span>(); <span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">0</span>; <span class="built_in">ischr</span>(op); op = <span class="built_in">getc</span>()) s[len++] = op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line">ll a[N], n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>, [](ll x, ll y)&#123;<span class="keyword">return</span> x &gt; y;&#125;);</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    ll i = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(; i; i--)&#123;</span><br><span class="line">        <span class="keyword">if</span>((a[i] - a[i + <span class="number">1</span>]) * (n - i) &lt;= m)&#123;</span><br><span class="line">            m -= (a[i] - a[i + <span class="number">1</span>]) * (n - i);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            ll delta = m / (n - i);</span><br><span class="line">            m -= delta * (n - i);</span><br><span class="line">            ans = (n * (a[i + <span class="number">1</span>] + delta) - n + <span class="number">1ll</span>) + i + m;</span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">0</span>)&#123;</span><br><span class="line">        ans = n * a[<span class="number">1</span>] - n + <span class="number">1ll</span> + m;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="b1.-reverse-card-easy-version">B1. Reverse Card (Easy Version)</h2>
<h3 id="简要翻译-1">简要翻译</h3>
<p>给定两个上界 <span class="math inline">\(n, m\)</span>，求满足 <span class="math inline">\(a \in [1, n], b \in [1, m]\)</span>，且 <span class="math inline">\(b \operatorname{gcd}(a, b) | (a + b)\)</span> 的数对数量。</p>
<h3 id="思路解析-1">思路解析</h3>
<p>可以设 <span class="math inline">\(g = \gcd(a, b), a = xg, b = yg\)</span>，应有 <span class="math inline">\(\gcd(x, y) = 1\)</span>。</p>
<p>上式则变换为 <span class="math inline">\(yg^2 | (x + y) g\)</span>。进一步有 <span class="math inline">\((x + y) = kgy, x = (kg - 1)y, k \in \mathrm{N}_{+}\)</span>。</p>
<p>这说明 <span class="math inline">\(\gcd(x, y) = y\)</span>。想到 <span class="math inline">\(y = 1\)</span> 可以推出 <span class="math inline">\(b = g\)</span>，相当于求 <span class="math inline">\(a = (kg - 1)g\)</span> 的 <span class="math inline">\((a, g)\)</span> 对数。</p>
<p><span class="math display">\[
a = (kg - 1)g \leq n \Rightarrow k \le \frac{\frac{n}{g} + 1}{g}
\]</span></p>
<p>因为 <span class="math inline">\(g \leq n, m \leq 2 \cdot 10^6\)</span>，所以枚举 <span class="math inline">\(g\)</span> 计算即可。</p>
<p>复杂度 <span class="math inline">\(\Theta(\sum n)\)</span>。</p>
<h3 id="代码-1">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isalpha</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">iscapitcal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;Z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isletter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isalpha</span>(op) || <span class="built_in">iscapitcal</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isletter</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len; <span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op = <span class="built_in">getc</span>(); <span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">0</span>; <span class="built_in">ischr</span>(op); op = <span class="built_in">getc</span>()) s[len++] = op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(ll g = <span class="number">1</span>; g &lt;= <span class="built_in">min</span>(n, m); ++g)&#123;<span class="comment">// gcd(a, b) == b</span></span><br><span class="line">        ans += ((n / g) + <span class="number">1ll</span>) / g;</span><br><span class="line">        <span class="keyword">if</span>(g == <span class="number">1</span>) ans--;<span class="comment">// kg - 1 &gt; 0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="b2.-reverse-card-hard-version">B2. Reverse Card (Hard Version)</h2>
<h3 id="简要翻译-2">简要翻译</h3>
<p>和上题几乎一样，区别在于整除的两侧交换了，即 <span class="math inline">\((a + b) | b \operatorname{gcd}(a, b)\)</span></p>
<p>范围也是一样的。</p>
<h3 id="思路解析-2">思路解析</h3>
<p>这题就没有那么好的性质了。不过仍然可以设 <span class="math inline">\(g = \gcd(a, b), a = xg, b = yg\)</span>，应有 $ (x, y) = 1$。</p>
<p>化简后的式子变成 <span class="math inline">\(yg = k (x + y), k \in \mathrm{N}_{+}\)</span>。</p>
<p>因为 <span class="math inline">\(x, y\)</span> 互质，所以 <span class="math inline">\((x + y)\)</span> 与 <span class="math inline">\(x, y\)</span> 均互质。</p>
<p>整除关系必须成立，所以 <span class="math inline">\(g = k^\prime (x + y)\)</span>。</p>
<p>对于一个数对 <span class="math inline">\((x, y)\)</span>，<span class="math inline">\(a = k^\prime (x + y) x \leq n, b = k^\prime (x + y) y \leq m\)</span>。</p>
<p>所以有 <span class="math inline">\(k^\prime \leq \frac{n}{(x + y) x}, k^\prime \leq \frac{m}{(x+y) y}\)</span>。</p>
<p>乍一看，枚举 <span class="math inline">\(x, y\)</span> 复杂度会爆炸。</p>
<p>这个时候犯难了，以为正解是莫比乌斯反演或者欧拉函数性质之类的。</p>
<p>手搓一下有贡献的数对，发现有用的部分 <span class="math inline">\(x^2 \leq (x + y)x \leq n\)</span>，所以枚举上界可以压缩。</p>
<p>复杂度 <span class="math inline">\(\Theta(\sum \sqrt{nm})\)</span>。</p>
<h3 id="代码-2">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isalpha</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">iscapitcal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;Z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isletter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isalpha</span>(op) || <span class="built_in">iscapitcal</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isletter</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len; <span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op = <span class="built_in">getc</span>(); <span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">0</span>; <span class="built_in">ischr</span>(op); op = <span class="built_in">getc</span>()) s[len++] = op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>;</span><br><span class="line">ll n, m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    ll ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll p = <span class="number">1</span>; p * p &lt;= n; ++p)</span><br><span class="line">    <span class="keyword">for</span>(ll q = <span class="number">1</span>; q * q &lt;= m; ++q)</span><br><span class="line">    <span class="keyword">if</span>(__gcd(p, q) == <span class="number">1</span>)</span><br><span class="line">        ans += <span class="built_in">min</span>(n / ((p + q) * p), m / ((p + q) * q));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="c.-fenwick-tree">C. Fenwick Tree</h2>
<h3 id="简要翻译-3">简要翻译</h3>
<p>对于一个数列 <span class="math inline">\(A\)</span>，我们定义一个函数 <span class="math inline">\(f(A)\)</span>，它得到一个新数列 <span class="math inline">\(B\)</span>。</p>
<p><span class="math inline">\(B\)</span> 满足 <span class="math inline">\(b_k=\left( \sum\limits_{i = k - \operatorname{lowbit}(k) + 1}^{k} a_i \right) \bmod 998\,244\,353\)</span>，其实就是对 <span class="math inline">\(A\)</span> 求一次树状数组得到的数组。</p>
<p>现在定义 <span class="math inline">\(f^k(A) = f(f^{k - 1}(A))\)</span>，并给定 <span class="math inline">\(B = f^k(A)\)</span> 和 <span class="math inline">\(k\)</span>，构造一个可能的 <span class="math inline">\(A\)</span>。</p>
<h3 id="思路解析-3">思路解析</h3>
<p>手玩一下样例和几组小数据，可以发现两个性质：</p>
<ol type="1">
<li>奇数位置的值永远不变。</li>
<li>整个序列可以按递减的 <span class="math inline">\(2\)</span> 的整次幂的长度划分，就像树状数组一样。</li>
</ol>
<p>这启发我们计算每个数 <span class="math inline">\(a_i\)</span> 对于另一个位置 <span class="math inline">\(b_j\)</span> 的贡献。</p>
<p>定义 <span class="math inline">\(\operatorname{step}(x, 1) = x + \operatorname{lowbit}(x), \operatorname{step}(x, s) = \operatorname{step}(\operatorname{step}(x, s - 1), 1)\)</span>。</p>
<p>抽象到树状数组中，<span class="math inline">\(\operatorname{step}(x, s)\)</span> 就是 <span class="math inline">\(x\)</span> 向上跳 <span class="math inline">\(s\)</span> 步到达的节点。</p>
<p>那么 <span class="math inline">\(a_x\)</span> 有贡献的点只能是 <span class="math inline">\(\operatorname{step}(x, s), s \in N_{+}\)</span>。</p>
<p>只考虑 <span class="math inline">\(x\)</span> 对 <span class="math inline">\(y\)</span> 的贡献的话，不妨设一个新数组 <span class="math inline">\(s_{k, s}\)</span> 表示求 <span class="math inline">\(k\)</span> 次树状数组后 <span class="math inline">\(x\)</span> 对 <span class="math inline">\(\operatorname{step}(x, s)\)</span> 的贡献。</p>
<blockquote>
<p>边界条件有 <span class="math inline">\(s_0 = \left\{1, 0, 0, \ldots \right\}\)</span>，下标从 0 开始。</p>
<p>因为再做一次树状数组，<span class="math inline">\(\operatorname{step}(x, s)\)</span> 的位置上一定包含 <span class="math inline">\(\operatorname{step}(x, 0), \operatorname{step}(x, 1), \operatorname{step}(x, 2) \ldots\)</span> 中 <span class="math inline">\(a_x\)</span> 的贡献，所以 <span class="math inline">\(s_{k,i} = \sum\limits_{j = 1}^{i} s_{k - 1, j}\)</span>。</p>
<p>这时可以发现，<span class="math inline">\(s_k\)</span> 与 <span class="math inline">\(x\)</span> 无关，实际上就是数列 <span class="math inline">\(s_0\)</span> 的 <span class="math inline">\(k\)</span> 次前缀和。</p>
</blockquote>
<p>经过计算推理可以得出 <span class="math inline">\(s_{k,s} = \binom{k + s - 1}{s}\)</span>。</p>
<p>这里 <span class="math inline">\(k\)</span> 很大但 <span class="math inline">\(s\)</span> 很小，Round 926 Div.2 F# 的暴力思路又涌上心头。</p>
<p>同时 <span class="math inline">\(0 \le s \le \log(N)\)</span>，所以对于每个 <span class="math inline">\(x\)</span> 直接枚举 <span class="math inline">\(\operatorname{step}(x, s)\)</span> 去除 <span class="math inline">\(x\)</span> 的贡献即可。</p>
<p>复杂度 <span class="math inline">\(\Theta(N \log^2 N)\)</span>，单次计算组合数的时间为 <span class="math inline">\(\Theta(\log N)\)</span>。</p>
<h3 id="代码-3">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isalpha</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">iscapitcal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;Z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isletter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isalpha</span>(op) || <span class="built_in">iscapitcal</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isletter</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len; <span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op = <span class="built_in">getc</span>(); <span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">0</span>; <span class="built_in">ischr</span>(op); op = <span class="built_in">getc</span>()) s[len++] = op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">300010</span>, lgN = <span class="number">40</span>;</span><br><span class="line"><span class="type">const</span> ll mod = <span class="number">998244353</span>;</span><br><span class="line"></span><br><span class="line">ll invfac[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">prework</span><span class="params">()</span></span>&#123;</span><br><span class="line">    invfac[<span class="number">0</span>] = invfac[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; lgN; ++i)</span><br><span class="line">        invfac[i] = (mod - mod / i) * invfac[mod % i] % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; lgN; ++i)</span><br><span class="line">        invfac[i] = invfac[i] * invfac[i - <span class="number">1</span>] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">binom</span><span class="params">(ll n, ll m)</span></span>&#123;<span class="comment">// small m</span></span><br><span class="line">    ll ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(ll i = n; i &gt;= n - m + <span class="number">1ll</span>; i--)</span><br><span class="line">        ans = ans * i % mod;</span><br><span class="line">    <span class="keyword">return</span> ans * invfac[m] % mod;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// suppose there&#x27;s a sequence s = [1, 0, 0, ...] (indexed from 0)</span></span><br><span class="line"><span class="comment">// C(k + j - 1, j) is the j-th item of k time&#x27;s suffix sequence of s</span></span><br><span class="line">ll b[N], a[N];</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); k = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        b[i] = (<span class="built_in">read</span>() % mod + mod) % mod;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)&#123;</span><br><span class="line">        a[i] = b[i];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = i, s = <span class="number">0</span>; x &lt;= n; x += x &amp; -x, s++)</span><br><span class="line">            b[x] = (b[x] + mod - a[i] * <span class="built_in">binom</span>(k + s - <span class="number">1</span>, s) % mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%lld &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="built_in">prework</span>();</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="d.-long-way-to-be-non-decreasing">D. Long Way to be Non-decreasing</h2>
<h3 id="简要翻译-4">简要翻译</h3>
<p>有一个序列 <span class="math inline">\(a_1, a_2, \ldots, a_n\)</span>，值域为 <span class="math inline">\([1, m]\)</span>。</p>
<p>同时规定一组变换 <span class="math inline">\(b_1, b_2, \ldots, b_m\)</span>，值域同样为 <span class="math inline">\([1, m]\)</span>。</p>
<p>你可以执行若干次操作，每次选中一个 <span class="math inline">\([n]\)</span> 的子集 <span class="math inline">\(S\)</span>， 对于所有的 <span class="math inline">\(x \in S\)</span>，将第 <span class="math inline">\(x\)</span> 个位置上的数从 <span class="math inline">\(a_x\)</span> 修改为 <span class="math inline">\(b_{a_x}\)</span>。</p>
<p>求出最少的操作次数，可以使 <span class="math inline">\(a\)</span> 成为不下降的序列。不可能则输出 <code>-1</code>。</p>
<h3 id="思路解析-4">思路解析</h3>
<p>看到了将 <span class="math inline">\(v\)</span> 修改为 <span class="math inline">\(b_v\)</span>，其实可以联想到建图。</p>
<p>对每个 <span class="math inline">\(i\)</span> 连一条 <span class="math inline">\(i \rightarrow b_i\)</span> 的边，对于一个点 <span class="math inline">\(a_x\)</span> 的操作就转化成在图上走一步。</p>
<p><span class="math inline">\(m\)</span> 个点 <span class="math inline">\(m\)</span> 条边，这张图是一个基环树森林（内向树森林）。</p>
<p>那么 <span class="math inline">\(a_i\)</span> 就能抽象为一个人 <span class="math inline">\(P_i\)</span> 初始在编号为 <span class="math inline">\(a_i\)</span> 的点上。</p>
<p>然后也可以发现 <span class="math inline">\(a_i\)</span> 之间在操作上是相互独立的，而最后需要满足一个不下降的性质。</p>
<p>求这个步数可以考虑二分答案，转化为 <span class="math inline">\(lim\)</span> 步之内能不能让所有的 <span class="math inline">\(a_i\)</span> 走到一个编号不降的状态。</p>
<p>先考虑 <span class="math inline">\(P_n\)</span>。我们应该让他走到编号最大的点。</p>
<p>那么最大的点编号为 <span class="math inline">\(m\)</span>，判断 <span class="math inline">\(a_n\)</span> 到 <span class="math inline">\(m\)</span> 的距离 <span class="math inline">\(d\)</span> 有没有 <span class="math inline">\(d \leq lim\)</span> 即可。</p>
<p>如果没有，说明 <span class="math inline">\(P_n\)</span> 不能走到 <span class="math inline">\(m\)</span>，又因为我们要保持序列的单调性，其他 <span class="math inline">\(P_i\)</span> 也不需要考虑 <span class="math inline">\(m\)</span> 了。</p>
<p>这时转而考虑 <span class="math inline">\(m - 1\)</span> 即可。一旦有一个 <span class="math inline">\(P_i\)</span> 不能安排到任何位置，说明 <span class="math inline">\(lim\)</span> 步不能形成单调不降的序列 <span class="math inline">\(a\)</span>。</p>
<p>这里用一个双指针实现比较简单。</p>
<p>至于判断可能性，可以适当提高二分的上界，如果最后落在上界则说明多少步都不可能形成单调的序列。</p>
<p>实现难点在于计算基环树上两点距离。时间复杂度 <span class="math inline">\(\Theta((N + M)\log M)\)</span>。</p>
<h3 id="代码-4">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BUFFLEN = <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BUFFLEN | <span class="number">2</span>], *p1 = buf, *p2 = buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1 == p2)</span><br><span class="line">            p1 = buf,</span><br><span class="line">            p2 = buf + <span class="built_in">fread</span>(buf, <span class="number">1</span>, BUFFLEN, stdin);</span><br><span class="line">        <span class="keyword">return</span> p1 == p2? EOF: *p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isalpha</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">iscapitcal</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> op &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; op &lt;= <span class="string">&#x27;Z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isletter</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isalpha</span>(op) || <span class="built_in">iscapitcal</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span>&amp; op)</span></span>&#123;<span class="keyword">return</span> <span class="built_in">isletter</span>(op);&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res; <span class="type">static</span> <span class="type">char</span> op, f;</span><br><span class="line">        <span class="keyword">for</span>(f = <span class="number">0</span>, op = <span class="built_in">getc</span>(); !<span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) f |= (op == <span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res = <span class="number">0</span>; <span class="built_in">isdgt</span>(op); op = <span class="built_in">getc</span>()) res = res * <span class="number">10</span> + (op ^ <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f? -res: res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len; <span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op = <span class="built_in">getc</span>(); <span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len = <span class="number">0</span>; <span class="built_in">ischr</span>(op); op = <span class="built_in">getc</span>()) s[len++] = op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="type">int</span>&gt; ver[N];</span><br><span class="line"><span class="type">int</span> fa[N], deg[N];</span><br><span class="line"><span class="type">int</span> q[N], pos[N], bel[N], siz[N], belcnt;</span><br><span class="line"><span class="type">int</span> dep[N], anc[N], dfnl[N], dfnr[N], dfncnt;</span><br><span class="line"><span class="type">bool</span> incir[N];</span><br><span class="line"><span class="type">int</span> a[N], n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x)</span></span>&#123;</span><br><span class="line">    dfnl[x] = ++dfncnt;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y : ver[x])</span><br><span class="line">    <span class="keyword">if</span>(!incir[y])&#123;</span><br><span class="line">        dep[y] = dep[x] + <span class="number">1</span>;</span><br><span class="line">        anc[y] = anc[x]; bel[y] = bel[x];</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">    dfnr[x] = dfncnt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischd</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y)</span></span>&#123;<span class="comment">// x is child of y</span></span><br><span class="line">    <span class="keyword">return</span> dfnl[y] &lt;= dfnl[x] &amp;&amp; dfnl[x] &lt;= dfnr[y];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ll <span class="title">dist</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; x, <span class="type">const</span> <span class="type">int</span>&amp; y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bel[x] != bel[y]) <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ischd</span>(x, y)) <span class="keyword">return</span> dep[x] - dep[y];</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">ischd</span>(y, x)) <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">if</span>(!incir[y]) <span class="keyword">return</span> inf;</span><br><span class="line">    <span class="keyword">return</span> dep[x] + (pos[y] + siz[bel[x]] - pos[anc[x]]) % siz[bel[x]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">chk</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp; lim)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> i = m, j = n;</span><br><span class="line">    <span class="keyword">while</span>(j)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &amp;&amp; <span class="built_in">dist</span>(a[j], i) &gt; lim) i--;</span><br><span class="line">        <span class="keyword">if</span>(!i) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        j--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        deg[i] = <span class="number">0</span>, incir[i] = <span class="number">0</span>,</span><br><span class="line">        bel[i] = <span class="number">0</span>, siz[i] = <span class="number">0</span>,</span><br><span class="line">        ver[i].<span class="built_in">clear</span>();</span><br><span class="line">    dfncnt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">findcir</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> ql = <span class="number">0</span>, qr = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="keyword">if</span>(!deg[i]) q[++qr] = i;</span><br><span class="line">    <span class="keyword">while</span>(ql &lt; qr)&#123;</span><br><span class="line">        <span class="type">int</span> x = q[++ql];</span><br><span class="line">        <span class="keyword">if</span>(!--deg[fa[x]]) q[++qr] = fa[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        incir[i] = deg[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n = <span class="built_in">read</span>(); m = <span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) a[i] = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)&#123;</span><br><span class="line">        fa[i] = <span class="built_in">read</span>();</span><br><span class="line">        ver[fa[i]].<span class="built_in">emplace_back</span>(i);</span><br><span class="line">        deg[fa[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">findcir</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, cnt = <span class="number">0</span>; i &lt;= m; ++i)</span><br><span class="line">    <span class="keyword">if</span>(deg[i])&#123;</span><br><span class="line">        belcnt++;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> x = i; deg[x]; x = fa[x])&#123;</span><br><span class="line">            deg[x] = <span class="number">0</span>; dep[x] = <span class="number">0</span>; anc[x] = x;</span><br><span class="line">            bel[x] = belcnt; ++siz[belcnt];</span><br><span class="line">            pos[x] = ++cnt;</span><br><span class="line">            <span class="built_in">dfs</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">chk</span>(m + <span class="number">1</span>))&#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;-1&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = m, mid;</span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">chk</span>(mid)) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, l);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T = <span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--) <span class="built_in">solve</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Discrete Mathematics Note Chapter 2</title>
    <url>/2024/06/14/Discrete-Mathematics-Note-Chapter-2/</url>
    <content><![CDATA[<h1 id="basic-structures-sets-functions-sequences-and-sums">Basic Structures: Sets, Functions, Sequences, and Sums</h1>
<span id="more"></span>
<h2 id="sets">Sets</h2>
<p>Definition: A <strong>set</strong> is an unordered collection of objects. The objects in are called <strong>elements</strong>. It is said to <strong>contain</strong> its elements.</p>
<p><span class="math inline">\(a \in A\)</span>: Element <span class="math inline">\(a\)</span> belongs to set <span class="math inline">\(A\)</span>.</p>
<h3 id="four-ways-to-describe">Four ways to describe</h3>
<ol type="1">
<li>Roster method: listing elements between braces. $S = {1, 2, 3,} $</li>
<li>Brace notation with ellipses <span class="math inline">\(S = \{1, 2, \ldots, 100\}\)</span></li>
<li>Specification using set builder: <span class="math inline">\(S = \{x | P(x)\}\)</span></li>
<li>Venn diagrams:
<ol type="1">
<li><span class="math inline">\(U\)</span> is represented in rectangle.</li>
<li>Different sets represented in circles in the rectangle.</li>
</ol></li>
</ol>
<p><span class="math inline">\(\emptyset\)</span>: Empty set, a set that contains nothing.</p>
<p><span class="math inline">\(U\)</span>: Universal set, containing all objects.</p>
<h3 id="relations-between-two-sets">Relations between Two Sets</h3>
<p><strong>Subset</strong>: <span class="math inline">\(A \subseteq B\)</span></p>
<p>​ <span class="math inline">\(\emptyset \subseteq A, A\subseteq A\)</span>.</p>
<p><strong>Proper Subset</strong>: <span class="math inline">\(A \subset B \Leftrightarrow (A \subseteq B\ \land\ A \neq B)\)</span>.</p>
<p><strong>Equal</strong>: <span class="math inline">\(A = B \Leftrightarrow (A \subseteq B\ \land \ B\subseteq A)\)</span>.</p>
<p><strong>Size</strong>: If there are exactly <span class="math inline">\(n\)</span> elements in <span class="math inline">\(S\)</span>, we call <span class="math inline">\(S\)</span> is <strong>finite</strong> and <span class="math inline">\(n\)</span> is the <strong>cardinality</strong> of <span class="math inline">\(S\)</span>.</p>
<p><strong>Power Set</strong>: The set containing all subsets of a given set. Attention, its elements are sets.</p>
<p>​ <span class="math inline">\(P(S) = \{X | X \subseteq S\}\)</span>.</p>
<p>​ <span class="math inline">\(|P| = 2^{|S|}\)</span>, so if <span class="math inline">\(S\)</span> is finite, then <span class="math inline">\(P\)</span> is finite.</p>
<p>​ Five rules: <span class="math inline">\(x \in P(S) \Rightarrow x \subseteq S\)</span>; $x S {x} P(S) $; <span class="math inline">\(S \in P(S)\)</span>.</p>
<p>​ <span class="math inline">\(P(A) \in P(B) \Rightarrow A \in B\)</span>; <span class="math inline">\(A \subseteq B \Rightarrow P(A) \subseteq P(B)\)</span>.</p>
<p>The <strong>ordered n-tuple</strong> <span class="math inline">\((a_1, a_2, \ldots, a_n)\)</span>. <span class="math inline">\((x, y) \neq (y, x)\)</span>.</p>
<p>The <strong>Cartesian product</strong> of two sets: <span class="math inline">\(A \times B = \{(a, b) | a \in A \land b \in B\}\)</span></p>
<p><strong>Truth Set</strong> of predicate <span class="math inline">\(P\)</span> in domain <span class="math inline">\(D\)</span> is <span class="math inline">\(\{x | P(x)\}\)</span>.</p>
<h2 id="set-operations">Set operations</h2>
<h3 id="operation-names">Operation Names</h3>
<p><strong>Union</strong>: <span class="math inline">\(A \bigcup B = \{x | x \in A \lor x\in B\}\)</span>.</p>
<p><strong>Intersection</strong>: <span class="math inline">\(A \bigcap B = \{x | x\in A \land x \in B\}\)</span>. If <span class="math inline">\(A \bigcap B = \emptyset\)</span>, then we call they are <strong>disjoint</strong>.</p>
<p><span class="math inline">\(|A \bigcup B| = |A| + |B| - |A \bigcap B|\)</span>.</p>
<p><strong>Difference</strong>: $ A - B = {x | x A x B} = A B$.</p>
<p><strong>Complement</strong>: <span class="math inline">\(\overline A = \{x | x \notin A \land x \in U\} = U - A\)</span>.</p>
<p><strong>Symmetric Difference</strong>: $A B = (A B) - (A B) $.</p>
<h3 id="set-identities">Set Identities</h3>
<p>Four ways to prove:</p>
<ol type="1">
<li>show that <span class="math inline">\(A \subseteq B\)</span> and <span class="math inline">\(B \subseteq A\)</span>.</li>
<li>Use logical equivalence to prove equivalent set definitions.</li>
<li>Use membership tables (like truth table).</li>
<li>Use previously proven identities.</li>
</ol>
<p>Some proven identities:</p>
<ol type="1">
<li>De Morgan's laws: <span class="math inline">\(\overline {(A \bigcup B)} = \overline{A} \bigcap \overline{B}\)</span>; <span class="math inline">\(\overline {(A \bigcap B)} = \overline{A} \bigcup \overline{B}\)</span>.</li>
<li>Distributive laws: <span class="math inline">\(A \bigcup (B \bigcap C) = (A \bigcup B) \bigcap (A \bigcup C)\)</span>; <span class="math inline">\(A \bigcap (B \bigcup C) = (A \bigcap B) \bigcup (A \bigcap C)\)</span>.</li>
</ol>
<h3 id="computer-representations">Computer Representations</h3>
<p>Use bit strings to represent.</p>
<p>First we know <span class="math inline">\(U = {a_1, a_2, a_3 ,\ldots}\)</span>, and <span class="math inline">\(|U| = n\)</span>.</p>
<p>Then we can use a bit string <span class="math inline">\(s\)</span> of length <span class="math inline">\(n\)</span> to represent any set, <span class="math inline">\(s_i = 1\)</span> if <span class="math inline">\(a_i\)</span> is in this set.</p>
<h2 id="functions">Functions</h2>
<h3 id="definition">Definition</h3>
<p>A <strong>function(mapping)</strong> <span class="math inline">\(f\)</span> from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>: <span class="math display">\[
f : A \rightarrow B\\
\forall a \exists! b (a \in A \rightarrow b \in B \land f(a) = b )
\]</span> <span class="math inline">\(A\)</span> is called the <strong>domain</strong>, <span class="math inline">\(B\)</span> is called <strong>codomain</strong>.</p>
<p><span class="math inline">\(f(a) = b\)</span>, then <span class="math inline">\(b\)</span> is called <strong>image</strong> of <span class="math inline">\(a\)</span>, <span class="math inline">\(a\)</span> is called <strong>preimage</strong> of <span class="math inline">\(b\)</span>.</p>
<p><span class="math inline">\(f(A) = \{f(a) | a \in A\}\)</span> is called <strong>range</strong>, and it's a subset of <span class="math inline">\(B\)</span>.</p>
<p>If <span class="math inline">\(f\)</span> is a function, we can call f <strong>maps</strong> <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>.</p>
<p><span class="math inline">\(f(\emptyset) = \emptyset\)</span>, <span class="math inline">\(f(\{ a \}) = \{ f(a) \}\)</span>.</p>
<p><span class="math inline">\(f(A \bigcup B) = f(A) \bigcup f(B)\)</span>.</p>
<p><span class="math inline">\(f(A \bigcap B) \subseteq f(A) \bigcap f(B)\)</span>.</p>
<h3 id="graph-of-functions">Graph of Functions</h3>
<p>The <strong>graph</strong> of the function <span class="math inline">\(f\)</span> is the set <span class="math inline">\(\{ (a, b) | a \in A \land b = f(a) \}\)</span>.</p>
<h3 id="injective-surjective-functions">Injective &amp; Surjective Functions</h3>
<p><strong>Injective</strong> (One-to-one) functions hold that <span class="math display">\[
\forall a \forall b (f(a) = f(b) \rightarrow a = b )
\]</span> That is, every element in domain has a unique image.</p>
<p><strong>Surjective</strong> (Onto) functions hold that <span class="math display">\[
\forall b \in B \exists a \in A (f(a) = b)
\]</span> That is, every element in codomain has at least one preimage.</p>
<p><strong>Bijection</strong> (One-to-one correspondence) is both one-to-one and onto.</p>
<p>Bijection's domain and codomain must have the same <strong>cardinality</strong>.</p>
<h3 id="monotonic-function">Monotonic Function</h3>
<p>Monotonically (strictly) increasing: <span class="math inline">\(x &lt; y \rightarrow f(x) &lt; f(y)\)</span>.</p>
<p>Monotonically (strictly) decreasing: <span class="math inline">\(x &lt; y \rightarrow f(x) &gt; f(y)\)</span>.</p>
<h3 id="inverse-functions">Inverse Functions</h3>
<p>If <span class="math inline">\(f\)</span> is a bijection, the <strong>inverse function</strong> of <span class="math inline">\(f\)</span> can be defined as <span class="math inline">\(f^{-1}\)</span>, that <span class="math inline">\(f^{-1}(y) = x\ \mathrm{iff}\ f(x) = y\)</span>. <span class="math inline">\((f^{-1})^{-1} = f\)</span>.</p>
<p>Otherwise, the inversion doesn't exist.</p>
<h3 id="composition">Composition</h3>
<p>Let <span class="math inline">\(g\)</span> be a function from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>, and <span class="math inline">\(f\)</span> be a function from <span class="math inline">\(B\)</span> to <span class="math inline">\(C\)</span>. Then the <strong>composition</strong> of <span class="math inline">\(g\)</span> and <span class="math inline">\(f\)</span> is <span class="math display">\[
f\ \circ\ g (a) = f(g(a))
\]</span> The range of <span class="math inline">\(g\)</span> must be a subset of the domain of <span class="math inline">\(f\)</span>.</p>
<h3 id="simple-important-functions">Simple Important Functions</h3>
<p>Floor Function <span class="math inline">\(\lfloor x \rfloor\)</span> (greatest integer below <span class="math inline">\(x\)</span>) and Ceiling Function <span class="math inline">\(\lceil x \rceil\)</span> (least integer above <span class="math inline">\(x\)</span>) are commonly used.</p>
<h4 id="properties">Properties</h4>
<details class="note info no-icon"><summary><p>Floor Properties</p>
</summary>
<ul>
<li><span class="math inline">\(x - 1 &lt; \lfloor x \rfloor \leq x \leq \lceil x \rceil &lt; x + 1\)</span>.</li>
<li><span class="math inline">\(\lfloor -x \rfloor = - \lceil x \rceil\)</span>.</li>
<li><span class="math inline">\(\lceil -x \rceil = - \lfloor x \rfloor\)</span>.</li>
<li><span class="math inline">\(\lfloor x + m \rfloor = \lfloor x \rfloor + m, \lceil x + m \rceil = \lceil x \rceil + m\)</span>, if <span class="math inline">\(m\)</span> is an integer.</li>
</ul>

</details>
<h2 id="sequence-and-summations">Sequence and Summations</h2>
<h3 id="definition-1">Definition</h3>
<p>A <strong>sequence</strong> is a function from a subset of the set of integers <span class="math inline">\([N]\)</span> to a set <span class="math inline">\(S\)</span>. We use the notation <span class="math inline">\(a_n\)</span> to denote <span class="math inline">\(f(n)\)</span>.</p>
<p>Note that the order in a sequence matters.</p>
<h3 id="geometric-progression">Geometric Progression</h3>
<p>A sequence of the form <span class="math inline">\(a, aq, aq^2, \dots, aq^{n-1}\)</span>.</p>
<h3 id="arithmetic-progression">Arithmetic Progression</h3>
<p>A sequence of the form <span class="math inline">\(a, a + d, a + 2d, \ldots, a + (n - 1)d\)</span>.</p>
<h3 id="summation">Summation</h3>
<p><span class="math display">\[
\sum_{i=m} ^n a_i,\quad \sum _{x\in S} f(x)
\]</span></p>
<p><span class="math inline">\(m\)</span>: lower bound, <span class="math inline">\(n\)</span>: upper bound, <span class="math inline">\(i\)</span>: index of summation;</p>
<p><span class="math inline">\(S\)</span> should be a subset of the domain of <span class="math inline">\(f\)</span>.</p>
<h4 id="useful-closed-form">Useful Closed Form</h4>
<ol type="1">
<li><p><span class="math inline">\(\large\sum\limits_{k = 0}^{n} ar^k = a \dfrac{r^{n + 1} - 1}{r - 1} (r \neq 0, 1)\)</span>.</p></li>
<li><p><span class="math inline">\(\large\sum\limits_{k = 1}^n k^2 = \dfrac{n (n + 1) (2n + 1)}{6}\)</span>.</p></li>
<li><p><span class="math inline">\(\large \sum \limits_{k = 1}^{n} k^3 = \dfrac{n^2 (n + 1)^2}{4} = \left(\dfrac{n (n + 1)}{2}\right)^2\)</span>.</p></li>
</ol>
<h2 id="the-cardinality-of-an-infinite-set">The cardinality of an infinite set</h2>
<h3 id="definition-2">Definition</h3>
<p>The cardinality of a set <span class="math inline">\(A\)</span> is <strong>equal</strong> to the cardinality of a set <span class="math inline">\(B\)</span>, denoted <span class="math inline">\(|A| = |B|\)</span>, <span class="math inline">\(\mathrm{iff}\)</span> there exists a bijection from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>.</p>
<p>If there is an injection from <span class="math inline">\(A\)</span> to <span class="math inline">\(B\)</span>, then we have <span class="math inline">\(|A| \le |B|\)</span>. And if they have different cardinality, we say <span class="math inline">\(|A| &lt; |B|\)</span>.</p>
<p>Any real interval have the same cardinality, so they are equal. A bijection <span class="math inline">\(f\)</span> from <span class="math inline">\((a, b)\)</span> to <span class="math inline">\((c, d)\)</span>: <span class="math inline">\(\dfrac{f(x)-d}{c-d}=\dfrac{x-a}{b-a}\)</span>.</p>
<p>If a set is finite or has the same cardinality as <span class="math inline">\(N_{+}\)</span>, it is called <strong>countable</strong>. Otherwise it's called <strong>uncountable</strong>.</p>
<p>The cardinality of <strong>countable infinite</strong> set <span class="math inline">\(S\)</span> is <strong>aleph null</strong> <span class="math inline">\(\aleph_0\)</span>.</p>
<h3 id="amazing-conclusions">Amazing conclusions</h3>
<p>​ <span class="math inline">\(|Z| = |N^+|, |Q^+| = |N^+|\)</span>.</p>
<blockquote>
<p>To prove <span class="math inline">\(|Q^+| = |N^+|\)</span>, define <span class="math inline">\(S = \{ (p,q) | p, q \in N^+ \}\)</span>.</p>
<ol type="1">
<li><span class="math inline">\(Q^+ \subseteq S\)</span>, because <span class="math inline">\(r = \frac{p}{q} \in Q^+\)</span>, then <span class="math inline">\((p, q)\)</span> must be in <span class="math inline">\(S\)</span>.</li>
<li><span class="math inline">\(|S| = |N^+|\)</span>, because <span class="math inline">\((p, q)\)</span> can be put in the <span class="math inline">\(q\)</span>-th column of <span class="math inline">\(p\)</span>-th row in the table, and we can pick them up in the antidiagonal order <span class="math inline">\((1, 1), (2, 1), (1, 2), (3, 1), (2, 2) \ldots\)</span>.</li>
<li><span class="math inline">\(N^+ \subseteq Q^+\)</span>.</li>
</ol>
</blockquote>
<h3 id="property">Property</h3>
<ol type="1">
<li>No infinite set has a smaller cardinality than a countable set.</li>
<li>The union of two countable set is countable.</li>
<li>The union of finite number of countable sets is countable.</li>
<li>The union of countable number of countable sets is countable.</li>
</ol>
<h3 id="cantor-diagonalization-argument">Cantor Diagonalization Argument</h3>
<p><strong>Theorem</strong>: The set of real number between <span class="math inline">\(0\)</span> and <span class="math inline">\(1\)</span> is uncountable.</p>
<blockquote>
<p>Proof:</p>
<ol type="1">
<li><span class="math inline">\(|N^+| \le |A|\)</span></li>
</ol>
<p>a function <span class="math inline">\(f(n) = \frac{1}{n+1}\)</span> performs <span class="math inline">\(f : N^+ \rightarrow A\)</span>.</p>
<ol start="2" type="1">
<li><span class="math inline">\(| N^+ | \neq |A|\)</span></li>
</ol>
<p>Assume <span class="math inline">\(A\)</span> is countable, then let <span class="math inline">\(A = \{ r_1, r_2, \ldots, r_n \ldots \}\)</span>.</p>
<p>Then list</p>
<p><span class="math inline">\(r_1 = 0.d_{11}d_{12}d_{13}\ldots\)</span></p>
<p><span class="math inline">\(r_2 = 0.d_{21}d_{22}d_{23}\ldots\)</span></p>
<p><span class="math inline">\(r_3 = 0.d_{31}d_{32}d_{33}\ldots\)</span></p>
<p><span class="math inline">\(\ldots\)</span></p>
<p>Now construct <span class="math inline">\(x = 0.x_1x_2x_3\ldots\)</span></p>
<p><span class="math inline">\(x_i = p\)</span> if <span class="math inline">\(d_{ii} \neq p\)</span>, otherwise <span class="math inline">\(x_i = p + 1\)</span>.</p>
<p><span class="math inline">\(x\)</span> is not in <span class="math inline">\(A\)</span> since it's not equal to any <span class="math inline">\(r_i\)</span>.</p>
</blockquote>
<p>How to describe the cardinality of <span class="math inline">\((0, 1)\)</span>? We can see that <span class="math inline">\(|(0, 1)| = |R|\)</span>.</p>
<blockquote>
<p>Let <span class="math inline">\(f(x) = \tan x\)</span>.</p>
<p>There is an bijection from <span class="math inline">\(( -\frac{\pi}{2}, \frac{\pi}{2} )\)</span> to <span class="math inline">\((- \infty, + \infty)\)</span>.</p>
<p>Then <span class="math inline">\(|(0, 1)| = |( -\frac{\pi}{2}, \frac{\pi}{2} )| = |R|\)</span>.</p>
</blockquote>
<p>The cardinality of <span class="math inline">\(R\)</span> is <strong>aleph one</strong> <span class="math inline">\(\aleph_1\)</span>.</p>
<p>In cantor diagonalization argument, we try to list the elements of the set <span class="math inline">\(S\)</span> in a matrix.</p>
<p>Then we pick the them up in antidiagonal order, to form a sequence.</p>
<p>Finally if the sequence has the same cardinality as <span class="math inline">\(N^+\)</span>, we can prove <span class="math inline">\(|S| = |N^+|\)</span>.</p>
<h3 id="computability">Computability</h3>
<p>A function is <strong>computable</strong> is it can be computed by some programming language. Otherwise it's <strong>incomputable</strong>.</p>
<p><strong>Schrőder-Bernstein Theorem</strong>: If <span class="math inline">\(|A| \leq |B|\)</span> and <span class="math inline">\(|B| \leq |A|\)</span>, then <span class="math inline">\(|A| = |B|\)</span>.</p>
<p>To prove <span class="math inline">\(|A| = |B|\)</span>, find <span class="math inline">\(f : A \rightarrow B\)</span> and <span class="math inline">\(g : B \rightarrow A\)</span>.</p>
<p>The <strong>Continuum Hypothesis</strong> asserts that there's no cardinal number <span class="math inline">\(a\)</span> such that <span class="math inline">\(\aleph_0 &lt; a &lt; \aleph_1\)</span>.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Discrete Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>Discrete Mathematics Note Chapter 3</title>
    <url>/2024/06/14/Discrete-Mathematics-Note-Chapter-3/</url>
    <content><![CDATA[<h1 id="algorithm">Algorithm</h1>
<span id="more"></span>
<h2 id="algorithms">Algorithms</h2>
<h3 id="definition">Definition</h3>
<p>An <strong>algorithm</strong> is a finite set of precise instructions for performing a computation or for solving a problem.</p>
<h3 id="pseudo-code">Pseudo Code</h3>
<p>Instructions in generic language similar to real computer languages.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure max(a_1, a_2, ..., a_n: integers)</span><br><span class="line">maxa := a_1</span><br><span class="line">for i from 1 to n begin</span><br><span class="line">    if maxa &lt; a_i then begin</span><br><span class="line">        maxa := a_i</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">return maxa</span><br></pre></td></tr></table></figure>
<h3 id="common-properties-of-algorithms">Common properties of algorithms</h3>
<ul>
<li>Input</li>
<li>Output</li>
<li>Definiteness -- each step must be defined precisely</li>
<li>Correctness -- outputs are correct</li>
<li>Finiteness -- produce the desired output in finite steps</li>
<li>Effectiveness -- each step must be executed exactly and in a finite amount of time</li>
<li>Generality -- applicable for all problems of the desired form</li>
</ul>
<h3 id="searching-algorithm">Searching Algorithm</h3>
<h4 id="linear-search-sequential-search">Linear Search / Sequential Search</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure linear_search(x:integer, a_1, a_2, a_3, ..., a_n: integers)</span><br><span class="line">i := 1</span><br><span class="line">while i &lt;= n and x != a_i then i := i + 1</span><br><span class="line">if i &lt;= n then location := i</span><br><span class="line">else then location := n + 1</span><br><span class="line">return location</span><br></pre></td></tr></table></figure>
<h4 id="binary-search">Binary Search</h4>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure binary_search(x:integer, a_1, a_2, a_3, ..., a_n: integers)</span><br><span class="line">l := 1</span><br><span class="line">r := n</span><br><span class="line">while l &lt; r begin</span><br><span class="line">    mid := floor((l + r) / 2)</span><br><span class="line">    if x &gt; a_mid then l := mid + 1</span><br><span class="line">    else then r := mid</span><br><span class="line">end</span><br><span class="line">if x == a_l then location := l</span><br><span class="line">else then location := n + 1</span><br><span class="line">return location</span><br></pre></td></tr></table></figure>
<h3 id="other-algorithms">Other Algorithms</h3>
<h4 id="sorting">Sorting</h4>
<p>Sorting algorithms consist of <a href="https://www.runoob.com/w3cnote/bubble-sort.html">bubble sort</a>, <a href="https://www.runoob.com/w3cnote/insertion-sort.html">insertion sort</a>, <a href="https://www.runoob.com/w3cnote/selection-sort.html">selection sort</a>, <a href="https://www.runoob.com/w3cnote/merge-sort.html">merge sort</a>, <a href="https://www.runoob.com/w3cnote/quick-sort-2.html">quick sort</a> and so on.</p>
<h4 id="greedy-algorithm">Greedy Algorithm</h4>
<p>To solve problems like maximizing or minimizing some parameters.</p>
<p>Its strategy is to find partial best solutions, and construct the global best solution from them.</p>
<p>Pseudocode for change-making algorithm:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure make_change(c_1, c_2, c_3, ..., c_r: integers, n: integer)</span><br><span class="line">for i from 1 to r</span><br><span class="line">    d_i := 0</span><br><span class="line">while(n &gt;= c_i) begin</span><br><span class="line">    d_i := d_i + 1</span><br><span class="line">    n := n - c_i</span><br><span class="line">end</span><br><span class="line">return d</span><br></pre></td></tr></table></figure>
<h2 id="the-growth-of-functions">The Growth of Functions</h2>
<h3 id="asymptotic-analysis">Asymptotic Analysis</h3>
<p>The number of operations used by the algorithm as the input size approaches infinity is called <strong>asymptotic running time</strong>.</p>
<p>Asymptotic analysis is to roughly measure the running time of algorithms in a relative rate of growth of execution.</p>
<h3 id="big-o-notation">Big-O Notation</h3>
<p><span class="math inline">\(f(x)\)</span> is <span class="math inline">\(O(g(x))\)</span> if <span class="math inline">\(\exist n_0, C, \forall n&gt; n_0, f(n) \le Cg(n)\)</span>.</p>
<h3 id="big-omega-notation">Big-Omega Notation</h3>
<p><span class="math inline">\(f(x)\)</span> is <span class="math inline">\(\Omega(g(x))\)</span> if <span class="math inline">\(\exist n_0, C, \forall n&gt; n_0, f(n) \ge Cg(n)\)</span>.</p>
<h3 id="big-theta-notation">Big-Theta Notation</h3>
<p><span class="math inline">\(f(x)\)</span> is <span class="math inline">\(\Theta(g(x))\)</span> if it's both <span class="math inline">\(O(g(x))\)</span> and <span class="math inline">\(\Omega(g(x))\)</span>.</p>
<h3 id="notations-and-terms">Notations and Terms</h3>
<ul>
<li><span class="math inline">\(O(1)\)</span> -- Constant</li>
<li><span class="math inline">\(O(\log N)\)</span> -- logarithmic</li>
<li><span class="math inline">\(O(N)\)</span> -- linear</li>
<li><span class="math inline">\(O(N \log N)\)</span> -- <span class="math inline">\(N\)</span> log <span class="math inline">\(N\)</span></li>
<li><span class="math inline">\(O(N^b)\)</span> -- polynomial</li>
<li><span class="math inline">\(O(b^N) (b &gt; 1)\)</span> -- exponential</li>
<li><span class="math inline">\(O(n!)\)</span>​ -- factorial</li>
</ul>
<h3 id="simple-rules">Simple Rules</h3>
<ul>
<li><span class="math inline">\(O( (f_1 + f_2)(N) ) = O( \max(f_1(N), f_2(N)) )\)</span>.</li>
<li><span class="math inline">\(O( (f_1f_2)(N) ) = O( f_1(N) \cdot f_2(N) )\)</span>.</li>
</ul>
<h2 id="complexity-of-algorithms">Complexity of Algorithms</h2>
<h3 id="computational-complexity">Computational Complexity</h3>
<ul>
<li><strong>Space Complexity</strong>: Approximate amount of memory required to solve a problem with size <span class="math inline">\(n\)</span>.</li>
<li><strong>Time Complexity</strong>: Approximate amount of instructions required to solve a problem with size <span class="math inline">\(n\)</span>.
<ul>
<li>Instruction (basic operations):
<ul>
<li>searching -- comparisons</li>
<li>sorting -- list component comparisons</li>
<li>numerical operation -- floating point operations -- multiplications / division / addition / substraction</li>
</ul></li>
</ul></li>
</ul>
<h3 id="examples">Examples</h3>
<ol type="1">
<li>Finding the Maximum Element in a Finite Sequence</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure max(a_1, a_2, ..., a_n: integers)</span><br><span class="line">maxa := a_1</span><br><span class="line">for i from 1 to n begin</span><br><span class="line">    if maxa &lt; a_i then begin</span><br><span class="line">        maxa := a_i</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line">return maxa</span><br></pre></td></tr></table></figure>
<p>Solution:</p>
<blockquote>
<p>Measure the number of comparisons.</p>
<p>There are exactly <span class="math inline">\(2(n - 1) + 1 = 2n - 1\)</span> comparisons.</p>
<p>So the time complexity is <span class="math inline">\(\Theta(n)\)</span>.</p>
</blockquote>
<ol start="2" type="1">
<li>The Linear Search Algorithm</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">procedure linear_search(x: integer; a_1, a_2, ..., a_n: integers)</span><br><span class="line">i := 1</span><br><span class="line">while i &lt;= n and x != a_i begin</span><br><span class="line">    i := i + 1</span><br><span class="line">end</span><br><span class="line">if i &lt;= n then location := i</span><br><span class="line">else location := 0</span><br><span class="line">return location</span><br></pre></td></tr></table></figure>
<p>Solution:</p>
<blockquote>
<p>Measure the number of comparisons.</p>
<p>If <span class="math inline">\(x = a_j\)</span>, <span class="math inline">\(2j + 1\)</span> comparisons are used.</p>
<p>If the element is not in the list, there would be <span class="math inline">\(2n + 2\)</span> comparisons.</p>
<p>So its time complexity is <span class="math inline">\(O(n)\)</span>.</p>
</blockquote>
<h3 id="different-types-of-analysis">Different Types of Analysis</h3>
<ul>
<li>Worst-case analysis
<ul>
<li>Maximum number of operations</li>
<li>Usually the most complicated cases</li>
</ul></li>
<li>Best-case analysis</li>
<li>Average-case analysis
<ul>
<li>Average number of operations assuming an input probability distribution</li>
</ul></li>
</ul>
<h3 id="unsolvable-or-intractable">Unsolvable or Intractable</h3>
<p>Halting problem: given a program and an input to the program, whether the program will eventually halt when run.</p>
<p>Problems that can be shown that no algorithm exists for solving them are called <strong>unsolvable</strong>.</p>
<p>Problems that cannot be solved using an algorithm with polynomial worst-case time complexity are called <strong>intractable</strong>.</p>
<h3 id="p-and-np">P and NP</h3>
<p><strong>Class P</strong>: problems with polynomial time complexity solution.</p>
<p><strong>Class NP</strong>: problems without polynomial solution, but its answer can be checked in polynomial time.</p>
<p><strong>Class NP-Hard</strong>: there's a NP problem can be transfer into this problem in polynomial time.</p>
<p><strong>Class NP-Complete</strong>: problems both NP and NP-hard.</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>note</category>
      </categories>
      <tags>
        <tag>Discrete Mathematics</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 158 Solution</title>
    <url>/2023/11/26/Educational-Codeforces-Round-158-Solution/</url>
    <content><![CDATA[<p>目前进度：</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 15%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">E</th>
<th style="text-align: center;">F</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved later</td>
<td style="text-align: center;">not solved</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="a.-line-trip">A. Line Trip</h2>
<h3 id="简要翻译">简要翻译</h3>
<p>在一维数轴上，有一辆车，刚开始在 <span class="math inline">\(0\)</span> 且油箱为满，走一个单位消耗一升油，经过 <span class="math inline">\(a_1,a_2\ldots a_n\)</span> 处可加满油。</p>
<p>现在需要从 <span class="math inline">\(0\)</span> 走到 <span class="math inline">\(x\)</span> 再走回 <span class="math inline">\(0\)</span>，求能完成路径的油箱油量最小值。</p>
<h3 id="思路解析">思路解析</h3>
<p>先不考虑回程，设 <span class="math inline">\(a_0=0\)</span>，则 <span class="math inline">\(ans = \underset{1\le i\le n}{max} \lbrace a_{i}-a_{i-1} \rbrace\)</span>。</p>
<p>在 <span class="math inline">\(x\)</span> 处转弯时不能加油，所以有 <span class="math inline">\(ans = max(ans,2(x-a_n))\)</span>。</p>
<p>返程和去程一样，不用再统计。</p>
<h3 id="代码">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">100</span>;</span><br><span class="line"><span class="type">int</span> a[N],n,x;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    std::cin&gt;&gt;n&gt;&gt;x;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        std::cin&gt;&gt;a[i];</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">2</span>*(x-a[n]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans=std::<span class="built_in">max</span>(ans,a[i]-a[i<span class="number">-1</span>]);</span><br><span class="line">    std::cout&lt;&lt;ans&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;order.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;order.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    std::cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    std::cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="b.-chip-and-ribbon">B. Chip and Ribbon</h2>
<h3 id="简要翻译-1">简要翻译</h3>
<p>有一列 <span class="math inline">\(n\)</span> 个格子和一个指针，一开始格子里的数 <span class="math inline">\(a_i=0\)</span> 。</p>
<p>第 <span class="math inline">\(1\)</span> 步，Mococarp 会把指针放在第一个格子上，接下来每一步可以做下列两种移动之一：</p>
<ol type="1">
<li><p>若指针在第 <span class="math inline">\(i\)</span> 个格子上，且 <span class="math inline">\(i \neq n\)</span>，则将指针放在 <span class="math inline">\(i+1\)</span> 上。</p></li>
<li><p>将指针放在任意一个格子上（可以放在同一个格子上）。</p></li>
</ol>
<p>每一步之后，若指针在第 <span class="math inline">\(x\)</span> 个格子上，则 <span class="math inline">\(a_x\)</span> 加一。</p>
<p>现在，Mococarp 想尽可能少的使用移动 <span class="math inline">\(2\)</span>，使得 <span class="math inline">\(\forall i\in [1,n],a_i=c_i\)</span>。</p>
<h3 id="思路解析-1">思路解析</h3>
<p>只使用移动 <span class="math inline">\(1\)</span> 时相当于给一个区间加一，问题转化为用多少个区间可以使 <span class="math inline">\(i\)</span> 被 <span class="math inline">\(c_i\)</span> 个区间包含。</p>
<p>那么 <span class="math inline">\(c_i&gt;c_{i-1}\)</span> 时表示有 <span class="math inline">\(c_i -c_{i-1}\)</span> 个区间要从 <span class="math inline">\(i\)</span> 开始，<span class="math inline">\(ans+=c_i-c_{i-1}\)</span>。</p>
<h3 id="代码-1">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line">ll c[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cin&gt;&gt;c[i];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(c[i]&gt;c[i<span class="number">-1</span>])</span><br><span class="line">            ans+=c[i]-c[i<span class="number">-1</span>];</span><br><span class="line">    cout&lt;&lt;ans<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;order.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;order.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="c.-add-divide-and-floor">C. Add, Divide and Floor</h2>
<h3 id="简要翻译-2">简要翻译</h3>
<p>有一个数组 <span class="math inline">\(\lbrace a_n \rbrace\)</span>，每次可以选一个 <span class="math inline">\(x\)</span>，将所有 <span class="math inline">\(a_i\)</span> 赋值为 <span class="math inline">\(\lfloor \dfrac{a_i+x}{2} \rfloor\)</span>，求最少次数使 <span class="math inline">\(a_1=a_2=\cdots=a_n\)</span>。</p>
<h3 id="思路解析-2">思路解析</h3>
<p>先考虑两个数 <span class="math inline">\(x,y(x&lt;y)\)</span> 如何化为相等值。</p>
<p>考虑两者的差值，若选的数 <span class="math inline">\(v \ge 2\)</span> 则总有等效操作。</p>
<p>如果 <span class="math inline">\(v\ge 2\)</span> 且为偶数，则 <span class="math inline">\(\lfloor \dfrac{x+v}{2} \rfloor = \lfloor \dfrac{x}{2} \rfloor+\dfrac{v}{2}\)</span>，<span class="math inline">\(\lfloor \dfrac{y+v}{2} \rfloor = \lfloor \dfrac{y}{2} \rfloor+\dfrac{v}{2}\)</span>，和直接除以二的效果相同。</p>
<p>如果 <span class="math inline">\(v\ge 2\)</span> 且为奇数，则和加一再除以二的效果相同。</p>
<p>观察样例，在 <span class="math inline">\(x\)</span> 为奇数 且 <span class="math inline">\(y\)</span> 为偶数时，加一再除以二相当于除以二后只给 <span class="math inline">\(x\)</span> 加一。</p>
<p>其他情况下，加一再除以二不如直接除以二。</p>
<p>因为 <span class="math inline">\(x\le y \Leftrightarrow \lfloor \dfrac{x+v}{2} \rfloor \le \lfloor \dfrac{y+v}{2} \rfloor\)</span>，所以只用考虑数列中的最小值和最大值，其他值经过操作后也一定夹在两数中间。</p>
<h3 id="代码-2">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> a[N],n;</span><br><span class="line"><span class="type">int</span> Ans[N],len;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    len=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    std::<span class="built_in">sort</span>(a+<span class="number">1</span>,a+n+<span class="number">1</span>);</span><br><span class="line">    ll x=a[<span class="number">1</span>],y=a[n];<span class="comment">//仅最小值与最大值就可以了</span></span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(x!=y)&#123;</span><br><span class="line">            <span class="keyword">if</span>((x&amp;<span class="number">1</span>)==<span class="number">1</span>&amp;&amp;(y&amp;<span class="number">1</span>)==<span class="number">0</span>)&#123;<span class="comment">//x 奇数 &amp;&amp; y 偶数, +1 /2</span></span><br><span class="line">                Ans[++len]=<span class="number">1</span>;</span><br><span class="line">                x=(x+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">                y=(y+<span class="number">1</span>)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;<span class="comment">//其他, +0 /2</span></span><br><span class="line">                Ans[++len]=<span class="number">0</span>;</span><br><span class="line">                x&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">                y&gt;&gt;=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;len&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">if</span>(len&lt;=n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=len;++i)</span><br><span class="line">                cout&lt;&lt;Ans[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;order.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;order.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="d.-yet-another-monster-fight">D. Yet Another Monster Fight</h2>
<h3 id="简要翻译-3">简要翻译</h3>
<p>有 <span class="math inline">\(n\)</span> 个怪兽，第 <span class="math inline">\(i\)</span> 个的生命值为 <span class="math inline">\(a_i\)</span>。</p>
<p>Vasya 有闪电法术，他可以选择初始威力 <span class="math inline">\(x\)</span> 和攻击的第一个怪兽 <span class="math inline">\(i_1\)</span>。</p>
<p>每次攻击后，闪电会随机攻击一个尚未被攻击且旁边有被攻击过怪兽的怪兽。</p>
<p>第 <span class="math inline">\(k\)</span> 次攻击的怪兽 <span class="math inline">\(i_k\)</span> 收到 <span class="math inline">\((x-k+1)\)</span> 点伤害，这个值大于等于 <span class="math inline">\(a_i\)</span> 会使怪兽死亡。</p>
<p>现在 Vasya 想确定最小的 <span class="math inline">\(x\)</span>，使得在适当挑选 <span class="math inline">\(i_1\)</span> 后，无论闪电的攻击顺序如何，所有怪兽都会死亡。</p>
<h3 id="思路解析-3">思路解析</h3>
<p>对于 <span class="math inline">\(a_i\)</span>，考虑 <span class="math inline">\(i_1&lt;i\)</span> 和 <span class="math inline">\(i_1&gt;i\)</span> 的情况。</p>
<ol type="1">
<li><span class="math inline">\(i_1&lt;i\)</span>：<span class="math inline">\(a_i\)</span> 能影响 <span class="math inline">\(x\)</span> 取值的最坏情况是，把前 <span class="math inline">\(i-1\)</span> 个数都消灭之后再消灭 <span class="math inline">\(a_i\)</span>，对应的 <span class="math inline">\(x\)</span> 至少为 <span class="math inline">\(a_i+i-1\)</span>。</li>
<li><span class="math inline">\(i_1&gt;i\)</span>：最坏情况变为，把后面 <span class="math inline">\(a_{i+1} \sim a_n\)</span> 都消灭后再消灭 <span class="math inline">\(a_i\)</span>，对应的 <span class="math inline">\(x\)</span> 至少为 <span class="math inline">\(a_i+n-i\)</span>。</li>
</ol>
<p>第一种情况求后缀，第二种情况求前缀（<span class="math inline">\(\max\)</span>），然后 <span class="math inline">\(i_1=i\)</span> 时的答案为 $pre_{i-1}, a_i, nxt_{i+1} $，取最小值即可。</p>
<h3 id="代码-3">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::max;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line">ll a[N],pre[N],nxt[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        pre[i]=a[i]+n-i,<span class="comment">// i1 &gt; i</span></span><br><span class="line">        nxt[i]=a[i]+i<span class="number">-1</span>;<span class="comment">// i1 &lt; i</span></span><br><span class="line">    ll ans=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        pre[i]=<span class="built_in">max</span>(pre[i],pre[i<span class="number">-1</span>]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;--i)</span><br><span class="line">        nxt[i]=<span class="built_in">max</span>(nxt[i],nxt[i+<span class="number">1</span>]);</span><br><span class="line">    nxt[n+<span class="number">1</span>]=pre[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ans=std::<span class="built_in">min</span>(ans,<span class="built_in">max</span>(a[i],<span class="built_in">max</span>(pre[i<span class="number">-1</span>],nxt[i+<span class="number">1</span>])));</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;order.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;order.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="e.-compressed-tree">E. Compressed Tree</h2>
<h3 id="简要翻译-4">简要翻译</h3>
<p>有一棵 <span class="math inline">\(n\)</span> 个点的树，每个点有权值 <span class="math inline">\(a_i\)</span>。</p>
<p>在第一阶段，你可以选择任意一个有至多 <span class="math inline">\(1\)</span> 条边的点，并删除这个点和它所连的边。可以重复任意次。</p>
<p>在第二阶段，所有度为 <span class="math inline">\(2\)</span> 的点将被删去，原来和它相连的 <span class="math inline">\(2\)</span> 个点之间生成一条新边。一直重复直到不存在度为 <span class="math inline">\(2\)</span> 的点。</p>
<p>求压缩后剩下的点的权值和最大值。注意，权值可以是负数。</p>
<h3 id="思路分析">思路分析</h3>
<p>比赛时想到树形 dp，但是想到换根去了，最后浪费一个小时。</p>
<p>官方题解的说法，是按保不保留 <span class="math inline">\(x\)</span> 与父亲 <span class="math inline">\(fa_x\)</span> 的边，以及 <span class="math inline">\(x\)</span> 保留儿子的个数来讨论的。</p>
<p>设 <span class="math inline">\(f_x\)</span> 为<strong>保留</strong>边 <span class="math inline">\((x,fa_x)\)</span> 时，<span class="math inline">\(x\)</span> 及其子树内压缩后的最大权值和。</p>
<p>则讨论 <span class="math inline">\(x\)</span> 保留儿子的个数：</p>
<ol type="1">
<li><p>不保留： 只保留 <span class="math inline">\(x\)</span> 作为叶子，<span class="math inline">\(f_x =\max(f_x,a_x)\)</span>。</p></li>
<li><p>保留 <span class="math inline">\(1\)</span> 个：那么 <span class="math inline">\(x\)</span> 恰好有两条边，压缩后消失，<span class="math inline">\(f_x=\max(f_x,\underset{y}{\max}f_y)\)</span>。</p></li>
<li><p>保留 <span class="math inline">\(2\)</span> 个及以上：<span class="math inline">\(x\)</span> 可以保留，<span class="math inline">\(f_x=\max(f_x,a_x+\underset{y}{\sum}\max(0,f_y))\)</span>，至少选两个 <span class="math inline">\(f_y\)</span>。</p></li>
</ol>
<p>考虑<strong>不保留</strong>边 <span class="math inline">\((x,fa_x)\)</span> 时，<span class="math inline">\(x\)</span> 子树外的节点全部都被删除了。</p>
<p>再讨论保留儿子的个数：</p>
<ol type="1">
<li><p>不保留：<span class="math inline">\(ans=\max(ans,a_x)\)</span>。</p></li>
<li><p>保留 <span class="math inline">\(1\)</span> 个：<span class="math inline">\(ans=\max(ans,a_x+\underset{y}{max}f_y)\)</span>。</p></li>
<li><p>保留 <span class="math inline">\(2\)</span> 个：<span class="math inline">\(x\)</span> 恰好会被压缩，<span class="math inline">\(ans=\max(ans,\underset{y_1,y_2}{\max}(f_{y_1}+f_{y_2}))\)</span>。</p></li>
<li><p>保留 <span class="math inline">\(3\)</span> 个及以上：<span class="math inline">\(ans=\max(ans,\underset{y}{\sum}\max(0,f_y))\)</span>，至少选三个 <span class="math inline">\(f_y\)</span>。</p></li>
</ol>
<p>儿子个数用类似 <span class="math inline">\(01\)</span> 背包的写法，非常巧妙。</p>
<h3 id="代码-4">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> std::cin;</span><br><span class="line"><span class="keyword">using</span> std::cout;</span><br><span class="line"><span class="keyword">using</span> std::endl;</span><br><span class="line"><span class="keyword">using</span> std::vector;</span><br><span class="line"><span class="keyword">using</span> std::max;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> ll inf=<span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">500010</span>;</span><br><span class="line"></span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ver[N];</span><br><span class="line">ll val[N];</span><br><span class="line">ll f[N],ans;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        ver[i].<span class="built_in">clear</span>();</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> fa)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;ll&gt; <span class="title">sum</span><span class="params">(<span class="number">4</span>, -inf)</span></span>;</span><br><span class="line">    sum[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y : ver[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(y,x);</span><br><span class="line">        sum[<span class="number">3</span>]=<span class="built_in">max</span>(sum[<span class="number">3</span>],sum[<span class="number">3</span>]+f[y]);<span class="comment">//更新 f[y] 的和</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">3</span>;j;--j)<span class="comment">// 更新选 1/2 个时 f[y] 的最优值</span></span><br><span class="line">            sum[j]=<span class="built_in">max</span>(sum[j],sum[j<span class="number">-1</span>]+f[y]);</span><br><span class="line">    &#125;</span><br><span class="line">    f[x]=-inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;<span class="number">4</span>;++j)</span><br><span class="line">        f[x]=<span class="built_in">max</span>(f[x],sum[j]+(j==<span class="number">1</span>?<span class="number">0</span>:val[x])),</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,sum[j]+(j==<span class="number">2</span>?<span class="number">0</span>:val[x]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        cin&gt;&gt;val[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)&#123;</span><br><span class="line">        cin&gt;&gt;x&gt;&gt;y;</span><br><span class="line">        ver[x].<span class="built_in">push_back</span>(y);</span><br><span class="line">        ver[y].<span class="built_in">push_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line"><span class="comment">//  freopen(&quot;order.in&quot;,&quot;r&quot;,stdin);</span></span><br><span class="line"><span class="comment">//  freopen(&quot;order.out&quot;,&quot;w&quot;,stdout);</span></span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="literal">nullptr</span>)-&gt;<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    <span class="type">int</span> T;</span><br><span class="line">    cin&gt;&gt;T;</span><br><span class="line">    <span class="keyword">while</span>(T--)</span><br><span class="line">        <span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h3 id="f.-landscaping">F. Landscaping</h3>
<h3 id="简要翻译-5">简要翻译</h3>
<p>没看懂呢</p>
<h3 id="思路分析-1">思路分析</h3>
<p>没想出来呢</p>
<h3 id="代码-5">代码</h3>
<p>没写呢</p>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>Educational Codeforces Round 162 Solution</title>
    <url>/2024/02/26/Educational-Codeforces-Round-162-Solution/</url>
    <content><![CDATA[<p>目前进度：</p>
<table>
<colgroup>
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 17%" />
<col style="width: 15%" />
<col style="width: 17%" />
<col style="width: 12%" />
</colgroup>
<thead>
<tr class="header">
<th style="text-align: center;">A</th>
<th style="text-align: center;">B</th>
<th style="text-align: center;">C</th>
<th style="text-align: center;">D</th>
<th style="text-align: center;">E</th>
<th style="text-align: center;">F</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">solved later</td>
<td style="text-align: center;">solved contest</td>
<td style="text-align: center;">not solved</td>
</tr>
</tbody>
</table>
<span id="more"></span>
<h2 id="a.-moving-chips">A. Moving Chips</h2>
<h3 id="简要翻译">简要翻译</h3>
<p>给定一个 <span class="math inline">\(\texttt{01}\)</span> 串，每次可以把一个 <span class="math inline">\(\texttt{1}\)</span> 和左侧最近的一个 <span class="math inline">\(\texttt{0}\)</span> 交换，求把 <span class="math inline">\(\texttt{1}\)</span> 连成一块的最小步数。</p>
<h3 id="思路解析">思路解析</h3>
<p>将最左最右的 <span class="math inline">\(\texttt{1}\)</span> 包围起来的区间称为块。</p>
<p>每次 <span class="math inline">\(\texttt{1}\)</span> 向左动相当于 <span class="math inline">\(\texttt{0}\)</span> 向右动，考虑最少步数将块中的 <span class="math inline">\(\texttt{0}\)</span> 移到块的右侧。</p>
<p>那么每次将块中最右侧的 <span class="math inline">\(\texttt{0}\)</span> 与块末尾的 <span class="math inline">\(\texttt{1}\)</span> 交换即可。</p>
<p><span class="math inline">\(\Theta(n^2)\)</span> 的复杂度，可以接受。</p>
<h3 id="代码">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len;<span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op=<span class="built_in">getc</span>();<span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len=<span class="number">0</span>;<span class="built_in">ischr</span>(op);op=<span class="built_in">getc</span>())s[len++]=op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line"><span class="type">int</span> a[N],suma[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        a[i]=Input::<span class="built_in">read</span>(),</span><br><span class="line">        suma[i]=suma[i<span class="number">-1</span>]+a[i];</span><br><span class="line">    ll ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(!a[i])<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=i<span class="number">-1</span>;j;--j)</span><br><span class="line">            <span class="keyword">if</span>(!a[j]&amp;&amp;suma[j<span class="number">-1</span>])&#123;</span><br><span class="line">                a[j]=<span class="number">1</span>;</span><br><span class="line">                a[i]=<span class="number">0</span>;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> l=j;l&lt;i;++l)</span><br><span class="line">                    suma[l]++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="b.-monsters-attack">B. Monsters Attack!</h2>
<h3 id="简要翻译-1">简要翻译</h3>
<p>有 <span class="math inline">\(n\)</span> 个怪物，初始位置 <span class="math inline">\(x_i\)</span>，血量 <span class="math inline">\(a_i\)</span>，每秒向位置 <span class="math inline">\(0\)</span> 靠近 <span class="math inline">\(1\)</span>，到达 <span class="math inline">\(0\)</span> 时你死亡； 同时你每秒造成 <span class="math inline">\(k\)</span> 点伤害，可以任意分配。求能否击杀所有怪物。</p>
<h3 id="思路解析-1">思路解析</h3>
<p>贪心地想，应该先击杀早到 <span class="math inline">\(0\)</span> 的怪物。注意 <span class="math inline">\(x_i\)</span> 可以为负数，按 <span class="math inline">\(|x_i|\)</span> 考虑。</p>
<p>按 <span class="math inline">\(|x_i|\)</span> 将怪物排序，每次判断 <span class="math inline">\(|x_i| \times k \ge \sum_{j=1}^{i} a_j\)</span> 即可。</p>
<h3 id="代码-1">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len;<span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op=<span class="built_in">getc</span>();<span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len=<span class="number">0</span>;<span class="built_in">ischr</span>(op);op=<span class="built_in">getc</span>())s[len++]=op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line">ll h[N],pos[N],k;</span><br><span class="line"><span class="type">int</span> id[N],n;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();k=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        h[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        pos[i]=<span class="built_in">read</span>(),</span><br><span class="line">        id[i]=i;</span><br><span class="line">    <span class="built_in">sort</span>(id+<span class="number">1</span>,id+n+<span class="number">1</span>,[&amp;](<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(pos[x])&lt;<span class="built_in">abs</span>(pos[y]);</span><br><span class="line">    &#125;);</span><br><span class="line">    ll sumh=<span class="number">0</span>;</span><br><span class="line">    <span class="type">bool</span> ans=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;ans&amp;&amp;i&lt;=n;++i)&#123;</span><br><span class="line">        sumh+=h[id[i]];</span><br><span class="line">        <span class="keyword">if</span>(k*<span class="built_in">abs</span>(pos[id[i]])&lt;sumh)</span><br><span class="line">            ans=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(ans?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="c.-find-b">C. Find B</h2>
<h3 id="简要翻译-2">简要翻译</h3>
<p>给定正项序列 <span class="math inline">\(c\)</span>，每次询问一个子区间 <span class="math inline">\(a = \{c_l, \ldots, c_r\)</span>}，问能否构造满足条件的序列 <span class="math inline">\(b\)</span>：</p>
<ol type="1">
<li><p><span class="math inline">\(\sum\limits_{i=1}^{m} a_i = \sum\limits_{i=1}^{m} b_i\)</span>;</p></li>
<li><p><span class="math inline">\(a_i \neq b_i\)</span>;</p></li>
<li><p><span class="math inline">\(b_i &gt; 0\)</span>.</p></li>
</ol>
<h3 id="思路解析-2">思路解析</h3>
<p>对于某一项 <span class="math inline">\(x&gt;1\)</span>，将其变为 <span class="math inline">\(1\)</span> 可以空出 <span class="math inline">\(x-1\)</span> 放在其他的项上。</p>
<p>而 <span class="math inline">\(x=1\)</span> 的项则必须获得这样的值至少 <span class="math inline">\(1\)</span>。</p>
<p>如果一个子区间不存在 <span class="math inline">\(x=1\)</span> 的项，则每项 <span class="math inline">\(-1\)</span> ，多余的值放在最后一项即可。</p>
<p>如果存在 <span class="math inline">\(x=1\)</span> 的项，设 <span class="math inline">\(cnt\)</span> 为 <span class="math inline">\(x=1\)</span> 的项个数，<span class="math inline">\(sum\)</span> 为区间内 <span class="math inline">\(x&gt;1\)</span> 的项的 <span class="math inline">\(x-1\)</span> 之和。</p>
<p>只要 <span class="math inline">\(sum \ge cnt\)</span> 就能保证所有 <span class="math inline">\(1\)</span> 都能变为至少 <span class="math inline">\(2\)</span>，一定有方案；否则，一定有某个 <span class="math inline">\(b_i = a_i = 1\)</span>。</p>
<h3 id="代码-2">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len;<span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op=<span class="built_in">getc</span>();<span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len=<span class="number">0</span>;<span class="built_in">ischr</span>(op);op=<span class="built_in">getc</span>())s[len++]=op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line">ll a[N],suma[N],sum1[N];</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();m=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        a[i]=<span class="built_in">read</span>();</span><br><span class="line">        suma[i]=suma[i<span class="number">-1</span>];</span><br><span class="line">        sum1[i]=sum1[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span>(a[i]==<span class="number">1</span>)</span><br><span class="line">            sum1[i]++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            suma[i]+=a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> x,y,flag;</span><br><span class="line">    <span class="keyword">while</span>(m--)&#123;</span><br><span class="line">        x=<span class="built_in">read</span>();y=<span class="built_in">read</span>();</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(x==y)</span><br><span class="line">            flag=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="type">int</span> otherlen=y-x+<span class="number">1</span>-(sum1[y]-sum1[x<span class="number">-1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(suma[y]-suma[x<span class="number">-1</span>]-otherlen&lt;sum1[y]-sum1[x<span class="number">-1</span>])</span><br><span class="line">                flag=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">puts</span>(flag?<span class="string">&quot;YES&quot;</span>:<span class="string">&quot;NO&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="d.-slimes">D. Slimes</h2>
<h3 id="简要翻译-3">简要翻译</h3>
<p>有 <span class="math inline">\(n\)</span> 只史莱姆，第 <span class="math inline">\(i\)</span> 只初始大小为 <span class="math inline">\(a_i\)</span>。</p>
<p>每秒恰有一只史莱姆吃掉另一只。</p>
<p>设大小为 <span class="math inline">\(x\)</span> 的史莱姆吃掉大小为 <span class="math inline">\(y\)</span> 的史莱姆。则需满足 <span class="math inline">\(x&gt;y\)</span>，吃掉后 <span class="math inline">\(x\)</span> 变为 <span class="math inline">\(x+y\)</span>。</p>
<p>问对于每一只史莱姆 <span class="math inline">\(i\)</span>，最早在第几秒被吃掉。</p>
<h3 id="思路解析-3">思路解析</h3>
<p>每秒只有一只史莱姆能活动，那么最优方案一定是某只史莱姆吃到 <span class="math inline">\(i\)</span> 的旁边，再把它吃掉。</p>
<p>因为，如果一个方案是 <span class="math inline">\(i\)</span> 吃几只史莱姆再被吃掉，<span class="math inline">\(i\)</span> 吃下的史莱姆留给吃掉 <span class="math inline">\(i\)</span> 的史莱姆更优。</p>
<p>所以最优方案下 <span class="math inline">\(i\)</span> 不动。从左侧和右侧分别考虑答案。</p>
<p>容易发现，对于同样一段史莱姆 <span class="math inline">\([l,r]\)</span>，无论操作顺序如何，</p>
<p>剩一只史莱姆的时候其大小一定为 <span class="math inline">\(\sum\limits_{i=l}^{r} a_i\)</span>，同时一定经过了 <span class="math inline">\(r-l\)</span> 秒。</p>
<p>所以变为求左侧/右侧最短的区间，使得区间和大于 <span class="math inline">\(a_i\)</span>。向两侧二分/倍增即可。</p>
<p>这里有一种特殊情况：区间内所有数均相等时不能合并。</p>
<p>如果有至少两种数字，至少有一个最大值，其左右有比它小的值，合并之后依然如此。</p>
<p>所以合法区间内至少要有两种以上的数字（长度为 <span class="math inline">\(1\)</span> 的除外）。</p>
<p>赛时就推出来了，苦于二分和特判，最后寄了。</p>
<h3 id="代码-3">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">ischr</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;a&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;z&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">readstr</span><span class="params">(<span class="type">char</span> *s)</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">int</span> len;<span class="type">static</span> <span class="type">char</span> op;</span><br><span class="line">        <span class="keyword">do</span> op=<span class="built_in">getc</span>();<span class="keyword">while</span>(!<span class="built_in">ischr</span>(op));</span><br><span class="line">        <span class="keyword">for</span>(len=<span class="number">0</span>;<span class="built_in">ischr</span>(op);op=<span class="built_in">getc</span>())s[len++]=op;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">300010</span>;</span><br><span class="line">ll sum[N],a[N];</span><br><span class="line"><span class="type">int</span> ans[N],pre[N],nxt[N],n;</span><br><span class="line"><span class="function">ll <span class="title">calc</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;y)<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&lt;<span class="number">1</span>)<span class="keyword">return</span> sum[x];</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> sum[x]-sum[y<span class="number">-1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    a[n+<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        a[i]=<span class="built_in">read</span>();</span><br><span class="line">        sum[i]=sum[i<span class="number">-1</span>]+a[i];</span><br><span class="line">        ans[i]=(n&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        pre[i]=(a[i]==a[i<span class="number">-1</span>])?pre[i<span class="number">-1</span>]:i<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n;i;--i)</span><br><span class="line">        nxt[i]=(a[i]==a[i+<span class="number">1</span>])?nxt[i+<span class="number">1</span>]:i+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,l=<span class="number">0</span>;i&lt;=n;++i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i<span class="number">-1</span>]&gt;a[i])&#123;</span><br><span class="line">            ans[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lb=<span class="number">1</span>,rb=pre[i<span class="number">-1</span>],mid;</span><br><span class="line">        <span class="keyword">while</span>(lb+<span class="number">1</span>&lt;rb)&#123;</span><br><span class="line">            mid=(lb+rb)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">calc</span>(i<span class="number">-1</span>,mid)&gt;a[i])</span><br><span class="line">                lb=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                rb=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lb&gt;rb)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">calc</span>(i<span class="number">-1</span>,rb)&gt;a[i])&#123;</span><br><span class="line">            ans[i]=<span class="built_in">min</span>(ans[i],i-rb);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">calc</span>(i<span class="number">-1</span>,lb)&gt;a[i])&#123;</span><br><span class="line">            ans[i]=<span class="built_in">min</span>(ans[i],i-lb);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n<span class="number">-1</span>;i;--i)&#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i+<span class="number">1</span>]&gt;a[i])&#123;</span><br><span class="line">            ans[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> lb=nxt[i+<span class="number">1</span>],rb=n,mid;</span><br><span class="line">        <span class="keyword">while</span>(lb+<span class="number">1</span>&lt;rb)&#123;</span><br><span class="line">            mid=(lb+rb)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">calc</span>(i+<span class="number">1</span>,mid)&gt;a[i])</span><br><span class="line">                rb=mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                lb=mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(lb&gt;rb)<span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">calc</span>(i+<span class="number">1</span>,lb)&gt;a[i])&#123;</span><br><span class="line">            ans[i]=<span class="built_in">min</span>(ans[i],lb-i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">calc</span>(i+<span class="number">1</span>,rb)&gt;a[i])&#123;</span><br><span class="line">            ans[i]=<span class="built_in">min</span>(ans[i],rb-i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="keyword">if</span>(ans[i]==(n&lt;&lt;<span class="number">1</span>))ans[i]=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>,ans[i]);</span><br><span class="line">    <span class="built_in">putchar</span>(<span class="string">&#x27;\n&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="e.-count-paths">E. Count Paths</h2>
<h3 id="简要翻译-4">简要翻译</h3>
<p>给定一棵染色的树，求树上两个同颜色点间没有第三个同颜色点的点对数量。</p>
<h3 id="思路分析">思路分析</h3>
<p>回顾此题 <a href="https://codeforces.com/contest/1916/problem/E">Happy Life in University</a>，我们考虑类似的计算方法。</p>
<p>对于合法的点对，要么是父子关系，要么两者到 <span class="math inline">\(\mathrm{lca}\)</span> 的路径上都没有同颜色的点。</p>
<p>不妨设 <span class="math inline">\(1\)</span> 为树根。设 <span class="math inline">\(last_x\)</span> 为 <span class="math inline">\(x\)</span> 向上遇到的第一个同颜色的点，<span class="math inline">\(son_x\)</span> 表示 <span class="math inline">\(\lbrace y | last_y = x \rbrace\)</span>。</p>
<p>对于第一种情况，父子关系的答案为 <span class="math inline">\(\sum_{x} |son_x|\)</span>。</p>
<p>对于第二种情况，两点到 <span class="math inline">\(\mathrm{lca}\)</span> 时都不可能更新 <span class="math inline">\(last\)</span>，所以 <span class="math inline">\(last\)</span> 必定相同。</p>
<p>答案的大小就为 <span class="math inline">\(\sum_x \binom{|son_x|}{2}\)</span>。</p>
<p>这时，我们忽略了一个情况：<span class="math inline">\(y_1, y_2 \in son_x, \mathrm{lca}(y_1, y_2) = x\)</span>。它们也不是合法点对。</p>
<p>这种情况如何计数呢？</p>
<p>可以发现这种情况等价于 <span class="math inline">\(y_1, y_2\)</span> 分属 <span class="math inline">\(x\)</span> 的不同子树。</p>
<p>灵光一闪，可以发现，<span class="math inline">\(dfs\)</span> 搜索某个 <span class="math inline">\(y\)</span> 时，向 <span class="math inline">\(son_x\)</span> 添加的新点与 <span class="math inline">\(son_x\)</span> 中原有的点，它们恰好分属不同子树，应当删去。</p>
<p>最后特判 <span class="math inline">\(\mathrm{lca}(x,y) = 1\)</span> 的第二种点对，对每种颜色单独计算即可。</p>
<p>时间复杂度 <span class="math inline">\(\Theta(n)\)</span>。</p>
<h3 id="代码-4">代码</h3>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">namespace</span> Input&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> BuffLen=<span class="number">1</span>&lt;&lt;<span class="number">20</span>;</span><br><span class="line">    <span class="type">char</span> buf[BuffLen|<span class="number">2</span>],*p1=buf,*p2=buf;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">char</span> <span class="title">getc</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p1==p2)</span><br><span class="line">            p1=buf,</span><br><span class="line">            p2=buf+<span class="built_in">fread</span>(buf,<span class="number">1</span>,BuffLen,stdin);</span><br><span class="line">        <span class="keyword">return</span> p1==p2?EOF:*p1++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">bool</span> <span class="title">isdgt</span><span class="params">(<span class="type">const</span> <span class="type">char</span> op)</span></span>&#123;<span class="keyword">return</span> op&gt;=<span class="string">&#x27;0&#x27;</span>&amp;&amp;op&lt;=<span class="string">&#x27;9&#x27;</span>;&#125;</span><br><span class="line">    <span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">read</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="type">static</span> <span class="type">long</span> <span class="type">long</span> res;<span class="type">static</span> <span class="type">char</span> op,f;</span><br><span class="line">        <span class="keyword">for</span>(f=<span class="number">0</span>,op=<span class="built_in">getc</span>();!<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())f|=(op==<span class="string">&#x27;-&#x27;</span>);</span><br><span class="line">        <span class="keyword">for</span>(res=<span class="number">0</span>;<span class="built_in">isdgt</span>(op);op=<span class="built_in">getc</span>())res=res*<span class="number">10</span>+(op^<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">return</span> f?-res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">using</span> Input::read;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">long</span> <span class="type">long</span> ll;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N=<span class="number">200010</span>;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; son[N],ver[N],supson[N];</span><br><span class="line"><span class="type">int</span> col[N],fa[N];</span><br><span class="line"><span class="type">int</span> rev[N],lst[N];</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">ll ans;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">clear</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        son[i].<span class="built_in">clear</span>(),</span><br><span class="line">        ver[i].<span class="built_in">clear</span>(),</span><br><span class="line">        supson[i].<span class="built_in">clear</span>(),</span><br><span class="line">        fa[i]=<span class="number">0</span>;</span><br><span class="line">    ans=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">    lst[x]=rev[col[x]];</span><br><span class="line">    <span class="keyword">if</span>(lst[x])</span><br><span class="line">        son[lst[x]].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        supson[col[x]].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    rev[col[x]]=x;</span><br><span class="line">    ll minus=<span class="number">0</span>,lsts=<span class="number">0</span>;<span class="comment">//calculate pairs lca(y1, y2) = x</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> y : ver[x])&#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;</span><br><span class="line">        <span class="built_in">dfs</span>(y);</span><br><span class="line">        minus+=lsts*(son[x].<span class="built_in">size</span>()-lsts);<span class="comment">//old nodes * new nodes</span></span><br><span class="line">        lsts=son[x].<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    rev[col[x]]=lst[x];</span><br><span class="line">    ans-=minus;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">    n=<span class="built_in">read</span>();</span><br><span class="line">    <span class="built_in">clear</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)</span><br><span class="line">        col[i]=<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)&#123;</span><br><span class="line">        x=<span class="built_in">read</span>();</span><br><span class="line">        y=<span class="built_in">read</span>();</span><br><span class="line">        ver[x].<span class="built_in">emplace_back</span>(y);</span><br><span class="line">        ver[y].<span class="built_in">emplace_back</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;<span class="comment">//|son(x)| + C(|son(x)|, 2)</span></span><br><span class="line">        ll t=son[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!t)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=t+t*(t<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)&#123;<span class="comment">//lca(x,y) == 1, col[x] == col[y] != col[1]</span></span><br><span class="line">        ll t=supson[i].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(!t)<span class="keyword">continue</span>;</span><br><span class="line">        ans+=t*(t<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>,ans);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> T=Input::<span class="built_in">read</span>();</span><br><span class="line">    <span class="keyword">while</span>(T--)<span class="built_in">work</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>solution</tag>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title>批判性思维笔记</title>
    <url>/2023/11/15/%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B4%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="知识与批判">知识与批判</h2>
<h3 id="理性思维与非理性思维">理性思维与非理性思维</h3>
<p>理性思维：根据<strong>知识</strong>解决问题、做出决定或取得理解的<strong>思维形式</strong>。</p>
<ul>
<li>知识：能识别的，真(与事实相一致)的概念。</li>
</ul>
<p>非理性思维：凭感觉、情绪、习惯(<strong>经验</strong>)等做出决定或取得理解的思维形式。</p>
<ul>
<li>情绪、经验等驱动力是<strong>不稳定</strong>的，但会经常发生。</li>
</ul>
<p>感觉 VS 认为</p>
<span id="more"></span>
<h3 id="批判知识与事实">批判：知识与事实</h3>
<p>康德的批判哲学的主要观点，在探索问题之前先对于<strong>认识能力</strong>作测试。</p>
<p>人们开始争取摆脱实质生活的直接性的时候，要先获得关于普遍原理和观点的知识，根据理由支持或反对它，理解它的具体和丰富的内容，并作出有条理的判断。</p>
<p>对理论范畴的批判，是通过将理论范畴与实际的经验事实进行对比来实现的。</p>
<p>以前的知识：自然事实1&gt;知识1&gt;事实2&gt;知识2</p>
<p>现在的知识：自然事实1&gt;知识1&gt;知识2&gt;事实2</p>
<h3 id="批判性思维及其优点">批判性思维及其优点</h3>
<p>批判性思维：审慎地运用<strong>推理</strong>判断一个断言是否为真的思维形式。</p>
<p>理由：支持观点、主张、论题的一个/一组断言。</p>
<p>原因：事实发生的前提。</p>
<p><strong>与事实相一致</strong>的就是真的。</p>
<p>优点：</p>
<ul>
<li>合理性：提出任何结论都有可靠的理由（知识）。</li>
<li>反思性：对结论作检查或再思维。</li>
<li>前瞻性：形成新的结论（预言）。</li>
</ul>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>note</category>
      </categories>
  </entry>
  <entry>
    <title>重链剖分</title>
    <url>/2019/06/23/%E9%87%8D%E9%93%BE%E5%89%96%E5%88%86/</url>
    <content><![CDATA[<p><span class="math inline">\(2019.6.29\ update:\)</span>给出了时间复杂度的证明，更新了<span class="math inline">\(L_AT^EX\)</span></p>
<hr />
<p>先引入一个问题：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">给定一颗有n个节点的树，给定根节点</span><br><span class="line">每次给出点对(x,y)，查询x到y路径上深度最小的节点(即LCA)。</span><br></pre></td></tr></table></figure>
<figure>
<img src="https://cdn.luogu.com.cn/upload/pic/53670.png" alt="" /><figcaption>树</figcaption>
</figure>
<p>看到这样的题目，大家首先想到的是暴力吧？</p>
<ol type="1">
<li><p>从<span class="math inline">\(x\)</span>出发向上走到根，标记每个经过的节点。</p></li>
<li><p>从<span class="math inline">\(y\)</span>出发向上走，经过的第一个<strong>有标记</strong>的节点就是"x到y路径上深度最小的节点"<span class="math inline">\((LCA)\)</span>。</p></li>
</ol>
<figure>
<img src="https://cdn.luogu.com.cn/upload/pic/53671.png" alt="" /><figcaption>(3,2)</figcaption>
</figure>
<p><span class="math inline">\(Code:\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x==y)<span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">while</span>(x!=root)vis[x]=<span class="literal">true</span>,x=fa[x];</span><br><span class="line">    <span class="keyword">while</span>(y!=root)</span><br><span class="line">        <span class="keyword">if</span>(vis[y])<span class="keyword">return</span> y;</span><br><span class="line">        <span class="keyword">else</span> y=fa[y];</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是让我们算算复杂度... <span class="math inline">\(\Theta(N)\ \)</span><del>TLE</del></p>
<p>为什么复杂度如此之高？明显是因为走得太慢了。</p>
<p>我们需要更好的算法。</p>
<p>怎么做呢？</p>
<p>睿智的先人想到了<del>倍增</del><strong>树剖</strong></p>
<p>先把树剖分成一条条的链</p>
<p>每次直接跳一整条链，不就快了吗？</p>
<p>于是，树链剖分(<span class="math inline">\(Tree-chain\ Partition\)</span>)诞生了。</p>
<span id="more"></span>
<h2 id="预处理">预处理</h2>
<p>先来说剖分：</p>
<p><strong>剖分，是指依据某种运算，将几个节点分入同一条链，而将一颗树分成几条链的方法。</strong></p>
<p>看不懂没关系<del>反正它不重要</del></p>
<p>常见的剖分有三种： 1. 重链剖分 2. 实链剖分（Link-Cut Tree才用） 3. 长链剖分（几乎不用）</p>
<p>所以，我们讲的是<strong>重链剖分</strong></p>
<p>重链剖分依据啥呢？依据的是儿子的子树大小，即<span class="math inline">\(x\)</span><strong>子树最大</strong>的儿子与<span class="math inline">\(x\)</span>属于同一条重链。</p>
<p>首先定义几种变量： - <span class="math inline">\(dep_x\)</span>：<span class="math inline">\(x\)</span>的深度 - <span class="math inline">\(fa_x\)</span>：<span class="math inline">\(x\)</span>的父亲 - <span class="math inline">\(siz_x\)</span>：以<span class="math inline">\(x\)</span>为根的子树的节点数 - <span class="math inline">\(son_x\)</span>:<span class="math inline">\(x\)</span>的重儿子 - <span class="math inline">\(top_x\)</span>:<span class="math inline">\(x\)</span>所在重链的顶端编号 - <span class="math inline">\(root\)</span>:整棵树的根 - <span class="math inline">\(son(x)\)</span>:<span class="math inline">\(x\)</span>的儿子所构成的集合</p>
<p>所以我们先要dfs一遍把前4种值算出来。</p>
<p><span class="math inline">\(Code:\)</span></p>
<p>(<span class="math inline">\(head,ver,next\)</span>均为邻接表,不会的<del>你还看什么树剖</del>请先学会)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(ci&amp;x)</span></span>&#123;<span class="comment">//ci -&gt; const int,后文同</span></span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;<span class="built_in">dfs1</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(siz[son[x]]&lt;siz[y])son[x]=y;<span class="comment">//求重儿子</span></span><br><span class="line">        siz[x]+=siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下语句加在main(int argc,char **argv)/main() 中</span></span><br><span class="line">dep[root]=<span class="number">1</span>;<span class="built_in">dfs1</span>(root);</span><br></pre></td></tr></table></figure>
<p>算完了前<span class="math inline">\(4\)</span>种值，<span class="math inline">\(top\)</span>该怎么算呢？</p>
<p>根据定义，一条重链上的节点的<span class="math inline">\(top\)</span>值<strong>相同</strong>。</p>
<p>而在重链剖分中，<span class="math inline">\(x\)</span>和<span class="math inline">\(son_x\)</span>在<strong>一条</strong>重链上。</p>
<p><del>是不是发现了什么</del></p>
<p>于是我们得到了一条规律： <span class="math display">\[
top_x=
\begin{cases}
&amp;x &amp;|x\neq son_{fa_x}\\
&amp;top_{fa_x} &amp;|x=son_{fa_x}
\end{cases}
\]</span></p>
<p><del>是不是很简单</del></p>
<p>所以我们就可以愉快的<del>再dfs一遍</del>计算啦</p>
<p><span class="math inline">\(Code:\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(ci&amp;x)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!son[x])<span class="keyword">return</span>;</span><br><span class="line">    top[son[x]]=top[x];<span class="built_in">dfs2</span>(son[x]);<span class="comment">//直接在fa[x]处赋值，减少参数传递</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        top[y]=y;<span class="built_in">dfs2</span>(y);<span class="comment">//非重儿子的top[]一定是自己</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//以下语句加在main(int argc,char **argv)/main() 中</span></span><br><span class="line">top[root]=root;<span class="built_in">dfs2</span>(root);</span><br></pre></td></tr></table></figure>
<p>预处理复杂度<span class="math inline">\(\Theta(N)\)</span></p>
<p>剖完后的树 <img src="https://cdn.luogu.com.cn/upload/pic/53672.png" alt="例重链" /></p>
<h2 id="查找lca">查找LCA</h2>
<p>有人问，把链剖出来有对于查LCA什么用呢？</p>
<p>我答：还记得暴力为什么TLE吗？</p>
<p>走太慢啦！</p>
<p>所以，树链剖分的实际作用——加速！</p>
<p>但是，剖完后如何查找呢？</p>
<p><del>经过苦思冥想，</del> 我们发现一条规律：</p>
<p><strong>无论什么时候，只要两个节点不在一条重链上<span class="math inline">\((\)</span>即<span class="math inline">\(top_x!=top_y)\)</span>，那么他们的<span class="math inline">\(LCA\)</span>肯定不在深度大的那条重链上。</strong></p>
<p>所以，我们可以这样： 1. 对于点对<span class="math inline">\((x,y)\)</span>，记<span class="math inline">\(fx=top_x,fy=top_y\)</span>. 2. 如果<span class="math inline">\(fx!=fy\)</span>，转第3步；否则转第4步. 3. 将<span class="math inline">\(fx,fy\)</span>中<span class="math inline">\(dep[]\)</span>值大的往上跳(设<span class="math inline">\(dep_{fx}&gt;dep_{fy}\)</span>)，更新<span class="math inline">\(((x,y)-&gt;(fa_{fx},y))\)</span>，回到第2步. 4. 这时<span class="math inline">\((x,y)\)</span>肯定在一条重链上<span class="math inline">\((top_x=top_y)\)</span>，而深度较小的那个就是<span class="math inline">\(LCA\)</span>.</p>
<p><span class="math inline">\(Code:\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=top[x],fy=top[y];</span><br><span class="line">    <span class="keyword">while</span>(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fx]&lt;dep[fy])std::<span class="built_in">swap</span>(x,y),std::<span class="built_in">swap</span>(fx,fy);</span><br><span class="line">        x=fa[fx],fx=top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么这种加速跳法的效果怎么样呢？</p>
<p>可以证明单次操作的时间复杂度 <span class="math inline">\(\Theta(lgN)\)</span>。</p>
<details class="note primary"><summary><p>证明</p>
</summary>
<p>我们需要<span class="math inline">\(3\)</span>个定理：</p>
<ol type="1">
<li><span class="math inline">\(\forall y\in son(x)\  \&amp;\ y\neq son_x\)</span>，都有<span class="math inline">\(siz_y\le \frac{siz_x}{2}\)</span></li>
</ol>
<blockquote>
<p>反证法，假设有 <span class="math inline">\(siz_y&gt;\frac{siz_x}{2}\)</span>且<span class="math inline">\(y\in son(x)\)</span> 那么就有 <span class="math inline">\(y=son_x\)</span>，与定理矛盾 所以假设不成立，原命题成立</p>
</blockquote>
<ol start="2" type="1">
<li><span class="math inline">\(\forall x\in son(root)\)</span> ,从 <span class="math inline">\(root\)</span> 到 <span class="math inline">\(x\)</span> 的路径上存在不超过 <span class="math inline">\(lgN\)</span> 条轻边</li>
</ol>
<blockquote>
<p>因为每经过一条轻边，到达的点的<span class="math inline">\(siz\)</span>就会减半 所以最多减 <span class="math inline">\(lgN\)</span> 次 <span class="math inline">\(siz_x\)</span> 就变成 <span class="math inline">\(1\)</span> 了（到达叶子节点）</p>
</blockquote>
<ol start="3" type="1">
<li><span class="math inline">\(\forall x\in son(root)\)</span> ，从 <span class="math inline">\(root\)</span> 到 <span class="math inline">\(x\)</span> 的路径上存在不超过 <span class="math inline">\(lgN\)</span> 条重链</li>
</ol>
<blockquote>
<p>因为一条<strong>重链</strong>的<strong>两端</strong>必定是<strong>轻边</strong> 所以重链的数量比轻边少一条（重链通向 <span class="math inline">\(root\)</span> 除外） 最坏情况下轻重链数量一样，为 <span class="math inline">\(lgN\)</span></p>
</blockquote>
<p>如果每次我们跳过一条重链，这样的重链有 <span class="math inline">\(lgN\)</span> 条</p>
<p>时间复杂度就为 <span class="math inline">\(\Theta(lgN)\)</span> 啦</p>

</details>
<p>例题<a href="https://www.luogu.org/fe/problem/P3379">P3379</a></p>
<p>找<span class="math inline">\(LCA\)</span>的板子题</p>
<details class="note info no-icon"><summary><p>Code(DFS)</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> M 500010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ci const int</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> head[N],ver[M&lt;&lt;<span class="number">1</span>],next[M&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="type">int</span> dep[N],fa[N],siz[N],son[N],top[N];</span><br><span class="line"><span class="type">int</span> n,m,root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ci&amp;x,ci&amp;y)</span></span>&#123;ver[++tot]=y;next[tot]=head[x];head[x]=tot;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(ci&amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;<span class="built_in">dfs1</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(siz[son[x]]&lt;siz[y])son[x]=y;</span><br><span class="line">        siz[x]+=siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(ci&amp;x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!son[x])<span class="keyword">return</span>;</span><br><span class="line">    top[son[x]]=top[x];<span class="built_in">dfs2</span>(son[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        top[y]=y;<span class="built_in">dfs2</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);<span class="comment">//记得添双向边哦</span></span><br><span class="line">    dep[root]=<span class="number">1</span>;<span class="built_in">dfs1</span>(root);</span><br><span class="line">    top[root]=root;<span class="built_in">dfs2</span>(root);</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(x,y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<p>这里是<a href="https://www.luogu.org/recordnew/show/20058405">BFS实现版</a>（不知道为什么更慢）</p>
<details class="note info no-icon"><summary><p>Code(BFS)</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 500010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ci const int</span></span><br><span class="line"><span class="keyword">using</span> std::swap;</span><br><span class="line"><span class="type">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="type">int</span> dep[N],fa[N],son[N],siz[N],top[N];</span><br><span class="line"><span class="type">int</span> q[N],sta[N],seg[N],rev[N];</span><br><span class="line"><span class="type">int</span> n,m,root;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ci&amp;x,ci&amp;y)</span></span>&#123;ver[++tot]=y;next[tot]=head[x];head[x]=tot;&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bfs</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> l=<span class="number">0</span>,r=<span class="number">1</span>,x;</span><br><span class="line">    dep[q[<span class="number">1</span>]=root]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(l!=r)</span><br><span class="line">    &#123;</span><br><span class="line">        x=q[++l];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">        <span class="keyword">if</span>(!dep[y])</span><br><span class="line">            q[++r]=y,fa[y]=x,dep[y]=dep[x]+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r;x=q[i],i;--i)</span><br><span class="line">        ++siz[x],siz[fa[x]]+=siz[x];</span><br><span class="line">    siz[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;x=q[i],i&lt;=r;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!top[x])top[x]=x;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">        <span class="keyword">if</span>(y!=fa[x]&amp;&amp;siz[son[x]]&lt;siz[y])</span><br><span class="line">            son[x]=y;</span><br><span class="line">        <span class="keyword">if</span>(son[x])top[son[x]]=top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=r,tp,p;x=q[i],i;--i)</span><br><span class="line">        <span class="keyword">if</span>(siz[x]==<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(p=x,tp=<span class="number">0</span>;top[p]==top[x];p=fa[p])</span><br><span class="line">                sta[++tp]=p;</span><br><span class="line">            <span class="keyword">for</span>(;tp;--tp)</span><br><span class="line">                seg[sta[tp]]=++seg[<span class="number">0</span>],rev[seg[<span class="number">0</span>]]=sta[tp];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LCA</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dep[x]&lt;dep[y]?x:y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;n,&amp;m,&amp;root);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);</span><br><span class="line">    <span class="built_in">bfs</span>();</span><br><span class="line">    <span class="keyword">register</span> <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">LCA</span>(x,y));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<h2 id="套线段树">套线段树</h2>
<p>又有<del>睿智</del>聪明的小盆友问了：</p>
<p>这个奇怪的东西怎么套线段树呢？</p>
<p>我们来再看一看树链剖分后轻重边的分配情况：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/53672.png" /></p>
<p>如果我们把链拼成一个序列，就像这样：</p>
<p><img src="https://cdn.luogu.com.cn/upload/pic/53789.png" /></p>
<p>那么是不是可以用线段树维护呢？</p>
<p><del>不是也得是</del></p>
<p>如何确定每个节点在序列中的位置呢？</p>
<p>我们回到<span class="math inline">\(dfs2()\)</span>中</p>
<p>很容易发现一个性质：</p>
<p>对于同一条重链上的节点，他们一定是被<strong>连续访问</strong>的！</p>
<p>所以我们可以直接在<span class="math inline">\(dfs2()\)</span>中计算出每个节点在序列中的位置（其实就是重标号）</p>
<p><span class="math inline">\(Code:\)</span></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!son[x])<span class="keyword">return</span>;</span><br><span class="line">    seg[son[x]]=++cnt;rev[cnt]=son[x];<span class="comment">//rev[x]表示序列中x的对应树上节点</span></span><br><span class="line">    top[son[x]]=top[x];<span class="built_in">dfs2</span>(son[x]);<span class="comment">//直接访问son[x]保证连续性</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        seg[y]=++cnt;rev[cnt]=y;<span class="comment">//用seg[0]代替cnt可以省空间</span></span><br><span class="line">        top[y]=y;<span class="built_in">dfs2</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来的问题是：</p>
<p>如果要查询一条路径上的权值和/最大值，怎么办呢？</p>
<p>记<span class="math inline">\(x\)</span>到<span class="math inline">\(y\)</span>的<strong>路径权值和</strong>为<span class="math inline">\(sum(x,y)\)</span>。</p>
<p>来看这张图： <img src="https://cdn.luogu.com.cn/upload/pic/58441.png" /></p>
<p>假设现在查询<span class="math inline">\(sum(3,4)\)</span></p>
<p>将上图树拆成序列，用线段树维护 <img src="https://cdn.luogu.com.cn/upload/pic/58443.png" /></p>
<p>可以发现，如果<span class="math inline">\(top_x\neq top_y\)</span>，那么<span class="math inline">\(dep_{top}\)</span>较大的那条链的<strong>全部节点</strong>都在答案中（即<span class="math inline">\(sum(x,top_x)\in sum(x,y)\)</span> | {<span class="math inline">\(top_x\neq top_y\ \&amp;\ dep_x&gt;dep_y\)</span>}）</p>
<p>又因为我们的重链节点是<strong>连续储存</strong>的，在线段树中是一段<strong>区间</strong></p>
<p><del>不用我说了吧</del></p>
<p>和之前一样，当计算完当前链的答案后，<span class="math inline">\(x\)</span>跳到<span class="math inline">\(fa_{top_x}\)</span></p>
<p>最后<span class="math inline">\(top_x==top_y\)</span>时，只用计算<span class="math inline">\(sum(x,y)\)</span>这一段<strong>区间</strong>了。</p>
<p>整理一下：</p>
<ol type="1">
<li><p>设<span class="math inline">\(fx=top_x,fy=top_y\)</span>。</p></li>
<li><p>若<span class="math inline">\(fx==fy\)</span>，执行第4步；否则，设<span class="math inline">\(dep_x&gt;dep_y\)</span>，执行第三步。</p></li>
<li><p>计算<span class="math inline">\((x,top_x)\)</span>对答案的贡献，<span class="math inline">\(x=fa_{top_x}\)</span>。</p></li>
<li><p>设<span class="math inline">\(dep_x&lt;dep_y\)</span>，计算<span class="math inline">\((x,y)\)</span>对答案的贡献</p></li>
</ol>
<p><span class="math inline">\(Code:\)</span>（以求和为例）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=top[x],fy=top[y],ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fx]&lt;dep[fy])<span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(fx,fy);</span><br><span class="line">        ans+=<span class="built_in">ask_sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,seg[fx],seg[x]);</span><br><span class="line">        x=fa[fx],fx=top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    ans+=<span class="built_in">ask_sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,seg[x],seg[y]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，我们可以推广到 求<span class="math inline">\(max\)</span>/ 求<span class="math inline">\(min\)</span> /修改 的操作</p>
<p>因为每次跳重链都要进行<span class="math inline">\(\Theta(lgN)\)</span>的查询</p>
<p>所以时间复杂度<span class="math inline">\(\Theta(lg^2N)\)</span></p>
<p>例题<a href="https://www.luogu.org/fe/problem/P2590">P2590</a></p>
<p>认真看代码，不会很难</p>
<details class="note info no-icon"><summary><p>Code</p>
</summary>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 30010</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="type">int</span> dep[N],fa[N],siz[N],son[N],top[N];</span><br><span class="line"><span class="type">int</span> seg[N],rev[N],sum[N&lt;&lt;<span class="number">2</span>],maxn[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m,num[N];<span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span>&#123;ver[++tot]=y;next[tot]=head[x];head[x]=tot;&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;<span class="built_in">dfs1</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(siz[son[x]]&lt;siz[y])son[x]=y;</span><br><span class="line">        siz[x]+=siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!son[x])<span class="keyword">return</span>;</span><br><span class="line">    seg[son[x]]=++seg[<span class="number">0</span>];rev[seg[<span class="number">0</span>]]=son[x];<span class="comment">//分配线段树节点</span></span><br><span class="line">    top[son[x]]=top[x];<span class="built_in">dfs2</span>(son[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        seg[y]=++seg[<span class="number">0</span>];rev[seg[<span class="number">0</span>]]=y;</span><br><span class="line">        top[y]=y;<span class="built_in">dfs2</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span><span class="comment">//不会线段树的可以去逛我的blog</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;sum[p]=maxn[p]=num[rev[l]];<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">build</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    sum[p]=sum[p&lt;&lt;<span class="number">1</span>]+sum[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    maxn[p]=<span class="built_in">max</span>(maxn[p&lt;&lt;<span class="number">1</span>],maxn[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)&#123;sum[p]=maxn[p]=val;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">change</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x,val);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,val);</span><br><span class="line">    sum[p]=sum[p&lt;&lt;<span class="number">1</span>]+sum[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">    maxn[p]=<span class="built_in">max</span>(maxn[p&lt;&lt;<span class="number">1</span>],maxn[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask_sum</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)<span class="keyword">return</span> sum[p];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)ans=<span class="built_in">ask_sum</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)ans+=<span class="built_in">ask_sum</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask_max</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)<span class="keyword">return</span> maxn[p];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">-30000</span>;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)ans=<span class="built_in">ask_max</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)ans=<span class="built_in">max</span>(ans,<span class="built_in">ask_max</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y));</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_max</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//查询部分</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=top[x],fy=top[y],ans=<span class="number">-30000</span>;<span class="comment">//记得初始化</span></span><br><span class="line">    <span class="keyword">while</span>(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fx]&lt;dep[fy])<span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(fx,fy);</span><br><span class="line">        ans=<span class="built_in">max</span>(ans,<span class="built_in">ask_max</span>(<span class="number">1</span>,<span class="number">1</span>,n,seg[fx],seg[x]));<span class="comment">//fx~x的这条链</span></span><br><span class="line">        x=fa[fx],fx=top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    ans=<span class="built_in">max</span>(ans,<span class="built_in">ask_max</span>(<span class="number">1</span>,<span class="number">1</span>,n,seg[x],seg[y]));<span class="comment">//x~y的这条链</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query_sum</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=top[x],fy=top[y],ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fx!=fy)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[fx]&lt;dep[fy])<span class="built_in">swap</span>(x,y),<span class="built_in">swap</span>(fx,fy);</span><br><span class="line">        ans+=<span class="built_in">ask_sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,seg[fx],seg[x]);<span class="comment">//同上</span></span><br><span class="line">        x=fa[fx],fx=top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    ans+=<span class="built_in">ask_sum</span>(<span class="number">1</span>,<span class="number">1</span>,n,seg[x],seg[y]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="type">int</span> x,y;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;n;++i)</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;x,&amp;y),<span class="built_in">add</span>(x,y),<span class="built_in">add</span>(y,x);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;++i)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,num+i);</span><br><span class="line">    dep[<span class="number">1</span>]=rev[<span class="number">1</span>]=seg[<span class="number">0</span>]=seg[<span class="number">1</span>]=top[<span class="number">1</span>]=<span class="number">1</span>;<span class="comment">//记得初始化！！！</span></span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);<span class="built_in">dfs2</span>(<span class="number">1</span>);<span class="built_in">build</span>(<span class="number">1</span>,<span class="number">1</span>,n);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(*op==<span class="string">&#x27;C&#x27;</span>)<span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,n,seg[x],y);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(op[<span class="number">1</span>]==<span class="string">&#x27;M&#x27;</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_max</span>(x,y));</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query_sum</span>(x,y));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</details>
<hr />
<h3 id="后话">后话</h3>
<p>看完之后这些题就可以愉快地<del>WA</del><span class="math inline">\(AC\)</span>啦</p>
<ol type="1">
<li><a href="https://www.luogu.org/problemnew/show/P1505">【国家集训队】旅游</a></li>
</ol>
<p>主要是线段树上的区间修改</p>
<details class="note info no-icon"><summary><p>解法</p>
</summary>
<p>过程如下:</p>
<p>因为是区间<span class="math inline">\(*(-1)\)</span>，所以修改后最大值是<span class="math inline">\(-(\)</span>最小值<span class="math inline">\()\)</span>，最小值是<span class="math inline">\(-(\)</span>最大值<span class="math inline">\()\)</span>，区间和是<span class="math inline">\(-(\)</span>区间和<span class="math inline">\()\)</span></p>
<p><span class="math inline">\(Code:\)</span> <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void pushdown(ci&amp;p,ci&amp;l,ci&amp;r)//修改节点</span><br><span class="line">&#123;</span><br><span class="line">    tree[p]=Node(-tree[p].minn,//最大值 = -最小值</span><br><span class="line">                 -tree[p].maxn,//最小值 = -最大值</span><br><span class="line">                 -tree[p].sum,tree[p].tag^1);//区间和 = -区间和，标记 ^= 1</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 时间复杂度<span class="math inline">\(\Theta(Mlg^2N)\)</span></p>
<p><a href="https://www.luogu.org/recordnew/show/19845430">AC记录</a></p>
<details class="note info no-icon">
<summary>
<p>
Code
</p>
<p></summary> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N 200010</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ci const int</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> inf 0x3f3f3f3f</span></span><br><span class="line"><span class="keyword">using</span> std::max;</span><br><span class="line"><span class="keyword">using</span> std::min;</span><br><span class="line"><span class="keyword">using</span> std::swap;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Node</span>&#123;</span><br><span class="line">    <span class="type">int</span> maxn,minn,sum,tag;<span class="comment">//区间最小，区间最大，区间和，区间标记</span></span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> _1=<span class="number">0</span>,<span class="type">int</span> _2=<span class="number">0</span>,<span class="type">int</span> _3=<span class="number">0</span>,<span class="type">int</span> _4=<span class="number">0</span>):</span><br><span class="line">        <span class="built_in">maxn</span>(_1),<span class="built_in">minn</span>(_2),<span class="built_in">sum</span>(_3),<span class="built_in">tag</span>(_4)&#123;&#125;</span><br><span class="line">    Node <span class="keyword">operator</span> +(Node b)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Node</span>(<span class="built_in">max</span>(maxn,b.maxn),<span class="built_in">min</span>(minn,b.minn),</span><br><span class="line">                    sum+b.sum,tag|b.tag);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">Node tree[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],next[N&lt;&lt;<span class="number">1</span>],edge[N&lt;&lt;<span class="number">1</span>],tot=<span class="number">1</span>;<span class="comment">//储存有向图</span></span><br><span class="line"><span class="type">int</span> fa[N],dep[N],seg[N],siz[N],son[N],top[N];<span class="comment">//树剖必备 </span></span><br><span class="line"><span class="type">int</span> val[N],n,reb[N];<span class="type">char</span> op[<span class="number">5</span>];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(ci&amp;x,ci&amp;y,ci&amp;k)</span></span>&#123;ver[++tot]=y;edge[tot]=k;next[tot]=head[x];head[x]=tot;&#125;<span class="comment">//加条边</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(ci&amp;x)</span><span class="comment">//基本caozuo</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">        fa[y]=x;dep[y]=dep[x]+<span class="number">1</span>;<span class="comment">//更新fa[]与dep[]</span></span><br><span class="line">        val[y]=k;reb[k&gt;&gt;<span class="number">1</span>]=y;<span class="comment">//用val[x]代表x与fa[x]间的边,reb[k]表示标号为k的边在树上对应的节点</span></span><br><span class="line">        <span class="built_in">dfs1</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(siz[son[x]]&lt;siz[y])son[x]=y;siz[x]+=siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(ci&amp;x)</span><span class="comment">//同样的基本caozuo</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!son[x])<span class="keyword">return</span>;</span><br><span class="line">    seg[son[x]]=++seg[<span class="number">0</span>];</span><br><span class="line">    top[son[x]]=top[x];<span class="built_in">dfs2</span>(son[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        seg[y]=++seg[<span class="number">0</span>];</span><br><span class="line">        top[y]=y;<span class="built_in">dfs2</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">update</span><span class="params">(ci&amp;p)</span><span class="comment">//更新节点 </span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p]=<span class="built_in">Node</span>(<span class="built_in">max</span>(tree[p&lt;&lt;<span class="number">1</span>].maxn,tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].maxn),</span><br><span class="line">                 <span class="built_in">min</span>(tree[p&lt;&lt;<span class="number">1</span>].minn,tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].minn),</span><br><span class="line">                 tree[p&lt;&lt;<span class="number">1</span>].sum+tree[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>].sum,tree[p].tag);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(ci&amp;p,ci&amp;l,ci&amp;r)</span><span class="comment">//修改节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    tree[p]=<span class="built_in">Node</span>(-tree[p].minn,<span class="comment">//最大值 = -最小值</span></span><br><span class="line">                 -tree[p].maxn,<span class="comment">//最小值 = -最大值</span></span><br><span class="line">                 -tree[p].sum,tree[p].tag^<span class="number">1</span>);<span class="comment">//区间和 = -区间和，标记 ^= 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(ci&amp;p,ci&amp;l,ci&amp;r)</span><span class="comment">//标记下传</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!tree[p].tag)<span class="keyword">return</span>;tree[p].tag=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">pushdown</span>(p&lt;&lt;<span class="number">1</span>,l,mid);<span class="built_in">pushdown</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(ci&amp;x,ci&amp;k,ci&amp;p=<span class="number">1</span>,ci&amp;l=<span class="number">1</span>,ci&amp;r=n)</span><span class="comment">//单点修改权值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l==r)<span class="keyword">return</span> (<span class="type">void</span>)(tree[p]=<span class="built_in">Node</span>(k,k,k,<span class="number">0</span>));</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">spread</span>(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">change</span>(x,k,p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">change</span>(x,k,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">filp</span><span class="params">(ci&amp;x,ci&amp;y,ci&amp;p=<span class="number">1</span>,ci&amp;l=<span class="number">1</span>,ci&amp;r=n)</span><span class="comment">//区间 *= -1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)<span class="keyword">return</span> <span class="built_in">pushdown</span>(p,l,r);</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">spread</span>(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">filp</span>(x,y,p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)<span class="built_in">filp</span>(x,y,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="built_in">update</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">ask</span><span class="params">(ci&amp;x,ci&amp;y,ci&amp;p=<span class="number">1</span>,ci&amp;l=<span class="number">1</span>,ci&amp;r=n)</span><span class="comment">//区间查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)<span class="keyword">return</span> tree[p];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;Node ans=<span class="built_in">Node</span>(-inf,inf,<span class="number">0</span>,<span class="number">0</span>);<span class="built_in">spread</span>(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)ans=<span class="built_in">ask</span>(x,y,p&lt;&lt;<span class="number">1</span>,l,mid);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)ans=ans+<span class="built_in">ask</span>(x,y,p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">operate</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        <span class="built_in">filp</span>(seg[top[x]],seg[x]);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)<span class="built_in">filp</span>(seg[x]+<span class="number">1</span>,seg[y]);<span class="comment">//不能改LCA上的点</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Node <span class="title">query</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span><span class="comment">//路径查询</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node ans=<span class="built_in">Node</span>(-inf,inf,<span class="number">0</span>,<span class="number">0</span>);<span class="comment">//要初始化！！！ </span></span><br><span class="line">    <span class="keyword">while</span>(top[x]!=top[y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(dep[top[x]]&lt;dep[top[y]])<span class="built_in">swap</span>(x,y);</span><br><span class="line">        ans=ans+<span class="built_in">ask</span>(seg[top[x]],seg[x]);</span><br><span class="line">        x=fa[top[x]];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dep[x]&gt;dep[y])<span class="built_in">swap</span>(x,y);</span><br><span class="line">    <span class="keyword">if</span>(x!=y)ans=ans+<span class="built_in">ask</span>(seg[x]+<span class="number">1</span>,seg[y]);<span class="comment">//LCA上的答案不能算~</span></span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,x,y,k;i&lt;n;++i)</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d%d&quot;</span>,&amp;x,&amp;y,&amp;k),<span class="built_in">add</span>(x+<span class="number">1</span>,y+<span class="number">1</span>,k),<span class="built_in">add</span>(y+<span class="number">1</span>,x+<span class="number">1</span>,k);</span><br><span class="line">    dep[<span class="number">1</span>]=seg[<span class="number">0</span>]=seg[<span class="number">1</span>]=top[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);<span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">        <span class="built_in">change</span>(seg[i],edge[val[i]]);</span><br><span class="line">    <span class="type">int</span> x,y,m;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d\n&quot;</span>,&amp;m);</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;x,&amp;y);</span><br><span class="line">        <span class="keyword">if</span>(*op==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">            <span class="built_in">change</span>(seg[reb[x]],y);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(*op==<span class="string">&#x27;N&#x27;</span>)</span><br><span class="line">            <span class="built_in">operate</span>(x+<span class="number">1</span>,y+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            Node ans=<span class="built_in">query</span>(x+<span class="number">1</span>,y+<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span>(*op==<span class="string">&#x27;S&#x27;</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.sum);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>]==<span class="string">&#x27;A&#x27;</span>)</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.maxn);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,ans.minn);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</details>

</details>
<ol start="2" type="1">
<li><a href="https://www.luogu.org/fe/problem/P2146">软件包管理器</a></li>
</ol>
<details class="note info no-icon"><summary><p>解法</p>
</summary>
<p>运用 <span class="math inline">\(dfs()\)</span> 的性质 <span class="math inline">\(\rightarrow\)</span> 以 <span class="math inline">\(x\)</span> 为根的子树在线段树中为 <span class="math display">\[[seg[x],seg[x]+siz[x]-1]\]</span></p>
<p>时间复杂度 <span class="math inline">\(\Theta(Mlg^2N)\)</span></p>
<p><a href="https://www.luogu.org/recordnew/show/14296083">AC记录</a></p>
<details class="note info no-icon">
<summary>
<p>
Code
</p>
<p></summary> <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> N (int)1e6+10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> head[N],ver[N&lt;&lt;<span class="number">1</span>],next[N&lt;&lt;<span class="number">1</span>],tot;</span><br><span class="line"><span class="type">int</span> dep[N],fa[N],siz[N],son[N],top[N];</span><br><span class="line"><span class="type">int</span> seg[N],rev[N],sum[N&lt;&lt;<span class="number">2</span>];<span class="type">bool</span> tag[N&lt;&lt;<span class="number">2</span>],vis[N&lt;&lt;<span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n,m;<span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">const</span> <span class="type">int</span>&amp;x,<span class="type">const</span> <span class="type">int</span>&amp;y)</span></span>&#123;ver[++tot]=y;next[tot]=head[x];head[x]=tot;&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs1</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    siz[x]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x])<span class="keyword">continue</span>;</span><br><span class="line">        dep[y]=dep[x]+<span class="number">1</span>;<span class="built_in">dfs1</span>(y);</span><br><span class="line">        <span class="keyword">if</span>(siz[son[x]]&lt;siz[y])son[x]=y;</span><br><span class="line">        siz[x]+=siz[y];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs2</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!son[x])<span class="keyword">return</span>;</span><br><span class="line">    seg[son[x]]=++seg[<span class="number">0</span>];top[son[x]]=top[x];</span><br><span class="line">    rev[seg[<span class="number">0</span>]]=son[x];<span class="built_in">dfs2</span>(son[x]);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> k=head[x],y;y=ver[k],k;k=next[k])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(y==fa[x]||y==son[x])<span class="keyword">continue</span>;</span><br><span class="line">        seg[y]=++seg[<span class="number">0</span>];top[y]=y;</span><br><span class="line">        rev[seg[<span class="number">0</span>]]=y;<span class="built_in">dfs2</span>(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">spread</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!vis[p])<span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;</span><br><span class="line">    sum[p&lt;&lt;<span class="number">1</span>]=tag[p]*(mid-l+<span class="number">1</span>);sum[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=tag[p]*(r-mid);</span><br><span class="line">    tag[p&lt;&lt;<span class="number">1</span>]=tag[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=tag[p];vis[p&lt;&lt;<span class="number">1</span>]=vis[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>]=<span class="literal">true</span>;vis[p]=<span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y,<span class="type">bool</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)&#123;sum[p]=val*(r-l+<span class="number">1</span>);tag[p]=val;vis[p]=<span class="literal">true</span>;<span class="keyword">return</span>;&#125;</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>;<span class="built_in">spread</span>(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)<span class="built_in">change</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x,y,val);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)<span class="built_in">change</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y,val);</span><br><span class="line">    sum[p]=sum[p&lt;&lt;<span class="number">1</span>]+sum[p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ask</span><span class="params">(<span class="type">int</span> p,<span class="type">int</span> l,<span class="type">int</span> r,<span class="type">int</span> x,<span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=l&amp;&amp;r&lt;=y)<span class="keyword">return</span> sum[p];</span><br><span class="line">    <span class="type">int</span> mid=l+r&gt;&gt;<span class="number">1</span>,ans=<span class="number">0</span>;<span class="built_in">spread</span>(p,l,r);</span><br><span class="line">    <span class="keyword">if</span>(x&lt;=mid)ans+=<span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>,l,mid,x,y);</span><br><span class="line">    <span class="keyword">if</span>(y&gt;mid)ans+=<span class="built_in">ask</span>(p&lt;&lt;<span class="number">1</span>|<span class="number">1</span>,mid+<span class="number">1</span>,r,x,y);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//---------------------------------------------------------------</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">install</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> fx=top[x],k=x,ans=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fx!=<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ans+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>],seg[fx],seg[x]);</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>],seg[fx],seg[x],<span class="number">1</span>);</span><br><span class="line">        x=fa[fx],fx=top[x];</span><br><span class="line">    &#125;</span><br><span class="line">    ans+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>],<span class="number">1</span>,seg[x]);</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>],<span class="number">1</span>,seg[x],<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> dep[k]-ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">uninstall</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> ans=<span class="number">0</span>;</span><br><span class="line">    ans+=<span class="built_in">ask</span>(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],seg[x]+siz[x]<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">change</span>(<span class="number">1</span>,<span class="number">1</span>,seg[<span class="number">0</span>],seg[x],seg[x]+siz[x]<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;=n;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,fa+i);++fa[i];</span><br><span class="line">        <span class="built_in">add</span>(fa[i],i),<span class="built_in">add</span>(i,fa[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    dep[<span class="number">1</span>]=rev[<span class="number">1</span>]=seg[<span class="number">0</span>]=seg[<span class="number">1</span>]=top[<span class="number">1</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="built_in">dfs1</span>(<span class="number">1</span>);<span class="built_in">dfs2</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;m);<span class="type">int</span> x;</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s %d&quot;</span>,op,&amp;x);++x;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,*op==<span class="string">&#x27;i&#x27;</span>?<span class="built_in">install</span>(x):<span class="built_in">uninstall</span>(x));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</details>

</details>
<link rel="stylesheet" href="/css/spoiler.css" type="text/css"><script src="/js/spoiler.js" type="text/javascript" async></script>]]></content>
      <categories>
        <category>contest</category>
      </categories>
      <tags>
        <tag>Tutorial</tag>
      </tags>
  </entry>
</search>
